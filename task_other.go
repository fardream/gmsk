// Automatically generated by github.com/fardream/gen-gmsk
// function deinitions

package gmsk

// #include <stdlib.h> // for C.free
// #include <mosek.h>
import "C"

import (
	"unsafe"

	"github.com/fardream/gmsk/res"
)

// AnalyzeNames is wrapping [MSK_analyzenames],
// Analyze the names and issue an error for the first invalid name.
//
// Arguments:
//
//   - `whichstream` Index of the stream.
//   - `nametype` The type of names e.g. valid in MPS or LP files.
//
// [MSK_analyzenames]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.analyzenames
func (task *Task) AnalyzeNames(
	whichstream StreamType,
	nametype NameType,
) res.Code {
	return res.Code(
		C.MSK_analyzenames(
			task.task,
			C.MSKstreamtypee(whichstream),
			C.MSKnametypee(nametype),
		),
	)
}

// AnalyzeProblem is wrapping [MSK_analyzeproblem],
// Analyze the data of a task.
//
// Arguments:
//
//   - `whichstream` Index of the stream.
//
// [MSK_analyzeproblem]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.analyzeproblem
func (task *Task) AnalyzeProblem(
	whichstream StreamType,
) res.Code {
	return res.Code(
		C.MSK_analyzeproblem(
			task.task,
			C.MSKstreamtypee(whichstream),
		),
	)
}

// AnalyzeSolution is wrapping [MSK_analyzesolution],
// Print information related to the quality of the solution.
//
// Arguments:
//
//   - `whichstream` Index of the stream.
//   - `whichsol` Selects a solution.
//
// [MSK_analyzesolution]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.analyzesolution
func (task *Task) AnalyzeSolution(
	whichstream StreamType,
	whichsol SolType,
) res.Code {
	return res.Code(
		C.MSK_analyzesolution(
			task.task,
			C.MSKstreamtypee(whichstream),
			C.MSKsoltypee(whichsol),
		),
	)
}

// Basiscond is wrapping [MSK_basiscond],
// Computes conditioning information for the basis matrix.
//
// Arguments:
//
//   - `nrmbasis` An estimate for the 1-norm of the basis.
//   - `nrminvbasis` An estimate for the 1-norm of the inverse of the basis.
//
// [MSK_basiscond]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.basiscond
func (task *Task) Basiscond(
	nrmbasis *float64,
	nrminvbasis *float64,
) res.Code {
	return res.Code(
		C.MSK_basiscond(
			task.task,
			(*C.MSKrealt)(nrmbasis),
			(*C.MSKrealt)(nrminvbasis),
		),
	)
}

// BkToStr is wrapping [MSK_bktostr]
//
// [MSK_bktostr]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.bktostr
func (task *Task) BkToStr(
	bk BoundKey,
) (r res.Code, str string) {
	c_str := (*C.char)(C.calloc(MAX_STR_LEN+1, 1))
	defer C.free(unsafe.Pointer(c_str))

	r = res.Code(
		C.MSK_bktostr(
			task.task,
			C.MSKboundkeye(bk),
			c_str,
		),
	)

	if r.IsOk() {
		str = C.GoString(c_str)
	}

	return
}

// CheckMemtask is wrapping [MSK_checkmemtask]
//
// [MSK_checkmemtask]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.checkmemtask
func (task *Task) CheckMemtask(
	file string,
	line int32,
) res.Code {
	c_file := C.CString(file)
	defer C.free(unsafe.Pointer(c_file))

	return res.Code(
		C.MSK_checkmemtask(
			task.task,
			c_file,
			C.MSKint32t(line),
		),
	)
}

// Chgconbound is wrapping [MSK_chgconbound],
// Changes the bounds for one constraint.
//
// Arguments:
//
//   - `i` Index of the constraint for which the bounds should be changed.
//   - `lower` If non-zero, then the lower bound is changed, otherwise the upper bound is changed.
//   - `finite` If non-zero, then the given value is assumed to be finite.
//   - `value` New value for the bound.
//
// [MSK_chgconbound]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.chgconbound
func (task *Task) Chgconbound(
	i int32,
	lower int32,
	finite int32,
	value float64,
) res.Code {
	return res.Code(
		C.MSK_chgconbound(
			task.task,
			C.MSKint32t(i),
			C.MSKint32t(lower),
			C.MSKint32t(finite),
			C.MSKrealt(value),
		),
	)
}

// Chgvarbound is wrapping [MSK_chgvarbound],
// Changes the bounds for one variable.
//
// Arguments:
//
//   - `j` Index of the variable for which the bounds should be changed.
//   - `lower` If non-zero, then the lower bound is changed, otherwise the upper bound is changed.
//   - `finite` If non-zero, then the given value is assumed to be finite.
//   - `value` New value for the bound.
//
// [MSK_chgvarbound]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.chgvarbound
func (task *Task) Chgvarbound(
	j int32,
	lower int32,
	finite int32,
	value float64,
) res.Code {
	return res.Code(
		C.MSK_chgvarbound(
			task.task,
			C.MSKint32t(j),
			C.MSKint32t(lower),
			C.MSKint32t(finite),
			C.MSKrealt(value),
		),
	)
}

// Commitchanges is wrapping [MSK_commitchanges],
// Commits all cached problem changes.
//
// [MSK_commitchanges]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.commitchanges
func (task *Task) Commitchanges() res.Code {
	return res.Code(
		C.MSK_commitchanges(
			task.task,
		),
	)
}

// ConetypeToStr is wrapping [MSK_conetypetostr]
//
// Deprecated: [MSK_conetypetostr]/ConetypeToStr is deprecated by mosek and will be removed in a future release.
//
// [MSK_conetypetostr]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.conetypetostr
func (task *Task) ConetypeToStr(
	ct ConeType,
) (r res.Code, str string) {
	c_str := (*C.char)(C.calloc(MAX_STR_LEN+1, 1))
	defer C.free(unsafe.Pointer(c_str))

	r = res.Code(
		C.MSK_conetypetostr(
			task.task,
			C.MSKconetypee(ct),
			c_str,
		),
	)

	if r.IsOk() {
		str = C.GoString(c_str)
	}

	return
}

// DeleteSolution is wrapping [MSK_deletesolution],
// Undefine a solution and free the memory it uses.
//
// Arguments:
//
//   - `whichsol` Selects a solution.
//
// [MSK_deletesolution]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.deletesolution
func (task *Task) DeleteSolution(
	whichsol SolType,
) res.Code {
	return res.Code(
		C.MSK_deletesolution(
			task.task,
			C.MSKsoltypee(whichsol),
		),
	)
}

// DualSensitivity is wrapping [MSK_dualsensitivity],
// Performs sensitivity analysis on objective coefficients.
//
// Arguments:
//
//   - `subj` Indexes of objective coefficients to analyze.
//   - `leftpricej` Left shadow prices for requested coefficients.
//   - `rightpricej` Right shadow prices for requested coefficients.
//   - `leftrangej` Left range for requested coefficients.
//   - `rightrangej` Right range for requested coefficients.
//
// [MSK_dualsensitivity]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.dualsensitivity
func (task *Task) DualSensitivity(
	numj int32,
	subj *int32,
	leftpricej *float64,
	rightpricej *float64,
	leftrangej *float64,
	rightrangej *float64,
) res.Code {
	return res.Code(
		C.MSK_dualsensitivity(
			task.task,
			C.MSKint32t(numj),
			(*C.MSKint32t)(subj),
			(*C.MSKrealt)(leftpricej),
			(*C.MSKrealt)(rightpricej),
			(*C.MSKrealt)(leftrangej),
			(*C.MSKrealt)(rightrangej),
		),
	)
}

// EmptyAfeBarFRow is wrapping [MSK_emptyafebarfrow],
// Clears a row in barF
//
// Arguments:
//
//   - `afeidx` Row index of barF.
//
// [MSK_emptyafebarfrow]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.emptyafebarfrow
func (task *Task) EmptyAfeBarFRow(
	afeidx int64,
) res.Code {
	return res.Code(
		C.MSK_emptyafebarfrow(
			task.task,
			C.MSKint64t(afeidx),
		),
	)
}

// EmptyAfeBarFRowList is wrapping [MSK_emptyafebarfrowlist],
// Clears rows in barF.
//
// Arguments:
//
//   - `afeidxlist` Indices of rows in barF to clear.
//
// [MSK_emptyafebarfrowlist]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.emptyafebarfrowlist
func (task *Task) EmptyAfeBarFRowList(
	numafeidx int64,
	afeidxlist *int64,
) res.Code {
	return res.Code(
		C.MSK_emptyafebarfrowlist(
			task.task,
			C.MSKint64t(numafeidx),
			(*C.MSKint64t)(afeidxlist),
		),
	)
}

// EmptyAfeFCol is wrapping [MSK_emptyafefcol],
// Clears a column in F.
//
// Arguments:
//
//   - `varidx` Variable index.
//
// [MSK_emptyafefcol]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.emptyafefcol
func (task *Task) EmptyAfeFCol(
	varidx int32,
) res.Code {
	return res.Code(
		C.MSK_emptyafefcol(
			task.task,
			C.MSKint32t(varidx),
		),
	)
}

// EmptyAfeFColList is wrapping [MSK_emptyafefcollist],
// Clears columns in F.
//
// Arguments:
//
//   - `varidx` Indices of variables in F to clear.
//
// [MSK_emptyafefcollist]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.emptyafefcollist
func (task *Task) EmptyAfeFColList(
	numvaridx int64,
	varidx *int32,
) res.Code {
	return res.Code(
		C.MSK_emptyafefcollist(
			task.task,
			C.MSKint64t(numvaridx),
			(*C.MSKint32t)(varidx),
		),
	)
}

// EmptyAfeFRow is wrapping [MSK_emptyafefrow],
// Clears a row in F.
//
// Arguments:
//
//   - `afeidx` Row index.
//
// [MSK_emptyafefrow]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.emptyafefrow
func (task *Task) EmptyAfeFRow(
	afeidx int64,
) res.Code {
	return res.Code(
		C.MSK_emptyafefrow(
			task.task,
			C.MSKint64t(afeidx),
		),
	)
}

// EmptyAfeFRowList is wrapping [MSK_emptyafefrowlist],
// Clears rows in F.
//
// Arguments:
//
//   - `afeidx` Indices of rows in F to clear.
//
// [MSK_emptyafefrowlist]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.emptyafefrowlist
func (task *Task) EmptyAfeFRowList(
	numafeidx int64,
	afeidx *int64,
) res.Code {
	return res.Code(
		C.MSK_emptyafefrowlist(
			task.task,
			C.MSKint64t(numafeidx),
			(*C.MSKint64t)(afeidx),
		),
	)
}

// EvaluateAccs is wrapping [MSK_evaluateaccs],
// Evaluates the activities of all affine conic constraints.
//
// Arguments:
//
//   - `whichsol` Selects a solution.
//   - `activity` The activity of affine conic constraints. The array should have length equal to the sum of dimensions of all affine conic constraints.
//
// [MSK_evaluateaccs]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.evaluateaccs
func (task *Task) EvaluateAccs(
	whichsol SolType,
	activity *float64,
) res.Code {
	return res.Code(
		C.MSK_evaluateaccs(
			task.task,
			C.MSKsoltypee(whichsol),
			(*C.MSKrealt)(activity),
		),
	)
}

// Infeasibilityreport is wrapping [MSK_infeasibilityreport],
// Prints the infeasibility report to an output stream.
//
// Arguments:
//
//   - `whichstream` Index of the stream.
//   - `whichsol` Selects a solution.
//
// [MSK_infeasibilityreport]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.infeasibilityreport
func (task *Task) Infeasibilityreport(
	whichstream StreamType,
	whichsol SolType,
) res.Code {
	return res.Code(
		C.MSK_infeasibilityreport(
			task.task,
			C.MSKstreamtypee(whichstream),
			C.MSKsoltypee(whichsol),
		),
	)
}

// Initbasissolve is wrapping [MSK_initbasissolve],
// Prepare a task for basis solver.
//
// Arguments:
//
//   - `basis` The array of basis indexes to use.
//
// [MSK_initbasissolve]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.initbasissolve
func (task *Task) Initbasissolve(
	basis *int32,
) res.Code {
	return res.Code(
		C.MSK_initbasissolve(
			task.task,
			(*C.MSKint32t)(basis),
		),
	)
}

// Inputdata is wrapping [MSK_inputdata],
// Input the linear part of an optimization task in one function call.
//
// Arguments:
//
//   - `maxnumcon` Number of preallocated constraints in the optimization task.
//   - `maxnumvar` Number of preallocated variables in the optimization task.
//   - `c` Linear terms of the objective as a dense vector. The length is the number of variables.
//   - `cfix` Fixed term in the objective.
//   - `aptrb` Row or column start pointers.
//   - `aptre` Row or column end pointers.
//   - `asub` Coefficient subscripts.
//   - `aval` Coefficient values.
//   - `bkc` Bound keys for the constraints.
//   - `blc` Lower bounds for the constraints.
//   - `buc` Upper bounds for the constraints.
//   - `bkx` Bound keys for the variables.
//   - `blx` Lower bounds for the variables.
//   - `bux` Upper bounds for the variables.
//
// [MSK_inputdata]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.inputdata
func (task *Task) Inputdata(
	maxnumcon int32,
	maxnumvar int32,
	numcon int32,
	numvar int32,
	c *float64,
	cfix float64,
	aptrb *int32,
	aptre *int32,
	asub *int32,
	aval *float64,
	bkc *BoundKey,
	blc *float64,
	buc *float64,
	bkx *BoundKey,
	blx *float64,
	bux *float64,
) res.Code {
	return res.Code(
		C.MSK_inputdata(
			task.task,
			C.MSKint32t(maxnumcon),
			C.MSKint32t(maxnumvar),
			C.MSKint32t(numcon),
			C.MSKint32t(numvar),
			(*C.MSKrealt)(c),
			C.MSKrealt(cfix),
			(*C.MSKint32t)(aptrb),
			(*C.MSKint32t)(aptre),
			(*C.MSKint32t)(asub),
			(*C.MSKrealt)(aval),
			(*C.MSKboundkeye)(bkc),
			(*C.MSKrealt)(blc),
			(*C.MSKrealt)(buc),
			(*C.MSKboundkeye)(bkx),
			(*C.MSKrealt)(blx),
			(*C.MSKrealt)(bux),
		),
	)
}

// Inputdata64 is wrapping [MSK_inputdata64]
//
// [MSK_inputdata64]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.inputdata64
func (task *Task) Inputdata64(
	maxnumcon int32,
	maxnumvar int32,
	numcon int32,
	numvar int32,
	c *float64,
	cfix float64,
	aptrb *int64,
	aptre *int64,
	asub *int32,
	aval *float64,
	bkc *BoundKey,
	blc *float64,
	buc *float64,
	bkx *BoundKey,
	blx *float64,
	bux *float64,
) res.Code {
	return res.Code(
		C.MSK_inputdata64(
			task.task,
			C.MSKint32t(maxnumcon),
			C.MSKint32t(maxnumvar),
			C.MSKint32t(numcon),
			C.MSKint32t(numvar),
			(*C.MSKrealt)(c),
			C.MSKrealt(cfix),
			(*C.MSKint64t)(aptrb),
			(*C.MSKint64t)(aptre),
			(*C.MSKint32t)(asub),
			(*C.MSKrealt)(aval),
			(*C.MSKboundkeye)(bkc),
			(*C.MSKrealt)(blc),
			(*C.MSKrealt)(buc),
			(*C.MSKboundkeye)(bkx),
			(*C.MSKrealt)(blx),
			(*C.MSKrealt)(bux),
		),
	)
}

// LinkFiletotaskstream is wrapping [MSK_linkfiletotaskstream]
//
// [MSK_linkfiletotaskstream]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.linkfiletotaskstream
func (task *Task) LinkFiletotaskstream(
	whichstream StreamType,
	filename string,
	append int32,
) res.Code {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	return res.Code(
		C.MSK_linkfiletotaskstream(
			task.task,
			C.MSKstreamtypee(whichstream),
			c_filename,
			C.MSKint32t(append),
		),
	)
}

// OnesolutionSummary is wrapping [MSK_onesolutionsummary],
// Prints a short summary of a specified solution.
//
// Arguments:
//
//   - `whichstream` Index of the stream.
//   - `whichsol` Selects a solution.
//
// [MSK_onesolutionsummary]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.onesolutionsummary
func (task *Task) OnesolutionSummary(
	whichstream StreamType,
	whichsol SolType,
) res.Code {
	return res.Code(
		C.MSK_onesolutionsummary(
			task.task,
			C.MSKstreamtypee(whichstream),
			C.MSKsoltypee(whichsol),
		),
	)
}

// Optimize is wrapping [MSK_optimize],
// Optimizes the problem.
//
// Returns:
//
//   - `trmcode` Is either OK or a termination response code.
//
// [MSK_optimize]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.optimize
func (task *Task) Optimize() res.Code {
	return res.Code(
		C.MSK_optimize(
			task.task,
		),
	)
}

// OptimizeRmt is wrapping [MSK_optimizermt],
// Offload the optimization task to a solver server and wait for the solution.
//
// Arguments:
//
//   - `address` Address of the OptServer.
//   - `accesstoken` Access token.
//   - `trmcode` Is either OK or a termination response code.
//
// [MSK_optimizermt]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.optimizermt
func (task *Task) OptimizeRmt(
	address string,
	accesstoken string,
) (r, trmcode res.Code) {
	c_address := C.CString(address)
	defer C.free(unsafe.Pointer(c_address))

	c_accesstoken := C.CString(accesstoken)
	defer C.free(unsafe.Pointer(c_accesstoken))

	r = res.Code(
		C.MSK_optimizermt(
			task.task,
			c_address,
			c_accesstoken,
			(*C.MSKrescodee)(&trmcode),
		),
	)

	return
}

// OptimizerSummary is wrapping [MSK_optimizersummary],
// Prints a short summary with optimizer statistics from last optimization.
//
// Arguments:
//
//   - `whichstream` Index of the stream.
//
// [MSK_optimizersummary]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.optimizersummary
func (task *Task) OptimizerSummary(
	whichstream StreamType,
) res.Code {
	return res.Code(
		C.MSK_optimizersummary(
			task.task,
			C.MSKstreamtypee(whichstream),
		),
	)
}

// Optimizetrm is wrapping [MSK_optimizetrm]
//
// [MSK_optimizetrm]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.optimizetrm
func (task *Task) Optimizetrm() (r, trmcode res.Code) {
	r = res.Code(
		C.MSK_optimizetrm(
			task.task,
			(*C.MSKrescodee)(&trmcode),
		),
	)

	return
}

// PrimalRepair is wrapping [MSK_primalrepair],
// Repairs a primal infeasible optimization problem by adjusting the bounds on the constraints and variables.
//
// Arguments:
//
//   - `wlc` Weights associated with relaxing lower bounds on the constraints.
//   - `wuc` Weights associated with relaxing the upper bound on the constraints.
//   - `wlx` Weights associated with relaxing the lower bounds of the variables.
//   - `wux` Weights associated with relaxing the upper bounds of variables.
//
// [MSK_primalrepair]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.primalrepair
func (task *Task) PrimalRepair(
	wlc *float64,
	wuc *float64,
	wlx *float64,
	wux *float64,
) res.Code {
	return res.Code(
		C.MSK_primalrepair(
			task.task,
			(*C.MSKrealt)(wlc),
			(*C.MSKrealt)(wuc),
			(*C.MSKrealt)(wlx),
			(*C.MSKrealt)(wux),
		),
	)
}

// PrimalSensitivity is wrapping [MSK_primalsensitivity],
// Perform sensitivity analysis on bounds.
//
// Arguments:
//
//   - `subi` Indexes of constraints to analyze.
//   - `marki` Mark which constraint bounds to analyze.
//   - `subj` Indexes of variables to analyze.
//   - `markj` Mark which variable bounds to analyze.
//   - `leftpricei` Left shadow price for constraints.
//   - `rightpricei` Right shadow price for constraints.
//   - `leftrangei` Left range for constraints.
//   - `rightrangei` Right range for constraints.
//   - `leftpricej` Left shadow price for variables.
//   - `rightpricej` Right shadow price for variables.
//   - `leftrangej` Left range for variables.
//   - `rightrangej` Right range for variables.
//
// [MSK_primalsensitivity]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.primalsensitivity
func (task *Task) PrimalSensitivity(
	numi int32,
	subi *int32,
	marki *Mark,
	numj int32,
	subj *int32,
	markj *Mark,
	leftpricei *float64,
	rightpricei *float64,
	leftrangei *float64,
	rightrangei *float64,
	leftpricej *float64,
	rightpricej *float64,
	leftrangej *float64,
	rightrangej *float64,
) res.Code {
	return res.Code(
		C.MSK_primalsensitivity(
			task.task,
			C.MSKint32t(numi),
			(*C.MSKint32t)(subi),
			(*C.MSKmarke)(marki),
			C.MSKint32t(numj),
			(*C.MSKint32t)(subj),
			(*C.MSKmarke)(markj),
			(*C.MSKrealt)(leftpricei),
			(*C.MSKrealt)(rightpricei),
			(*C.MSKrealt)(leftrangei),
			(*C.MSKrealt)(rightrangei),
			(*C.MSKrealt)(leftpricej),
			(*C.MSKrealt)(rightpricej),
			(*C.MSKrealt)(leftrangej),
			(*C.MSKrealt)(rightrangej),
		),
	)
}

// PrintParam is wrapping [MSK_printparam],
// Prints the current parameter settings.
//
// [MSK_printparam]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.printparam
func (task *Task) PrintParam() res.Code {
	return res.Code(
		C.MSK_printparam(
			task.task,
		),
	)
}

// ProbtypeToStr is wrapping [MSK_probtypetostr]
//
// [MSK_probtypetostr]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.probtypetostr
func (task *Task) ProbtypeToStr(
	probtype ProblemType,
) (r res.Code, str string) {
	c_str := (*C.char)(C.calloc(MAX_STR_LEN+1, 1))
	defer C.free(unsafe.Pointer(c_str))

	r = res.Code(
		C.MSK_probtypetostr(
			task.task,
			C.MSKproblemtypee(probtype),
			c_str,
		),
	)

	if r.IsOk() {
		str = C.GoString(c_str)
	}

	return
}

// ProStaToStr is wrapping [MSK_prostatostr]
//
// [MSK_prostatostr]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.prostatostr
func (task *Task) ProStaToStr(
	problemsta ProSta,
) (r res.Code, str string) {
	c_str := (*C.char)(C.calloc(MAX_STR_LEN+1, 1))
	defer C.free(unsafe.Pointer(c_str))

	r = res.Code(
		C.MSK_prostatostr(
			task.task,
			C.MSKprostae(problemsta),
			c_str,
		),
	)

	if r.IsOk() {
		str = C.GoString(c_str)
	}

	return
}

// ReadBsolution is wrapping [MSK_readbsolution],
// Read a binary dump of the task solution and information items.
//
// Arguments:
//
//   - `filename` A valid file name.
//   - `compress` Data compression type.
//
// [MSK_readbsolution]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.readbsolution
func (task *Task) ReadBsolution(
	filename string,
	compress CompressType,
) res.Code {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	return res.Code(
		C.MSK_readbsolution(
			task.task,
			c_filename,
			C.MSKcompresstypee(compress),
		),
	)
}

// ReadData is wrapping [MSK_readdata],
// Reads problem data from a file.
//
// Arguments:
//
//   - `filename` A valid file name.
//
// [MSK_readdata]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.readdata
func (task *Task) ReadData(
	filename string,
) res.Code {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	return res.Code(
		C.MSK_readdata(
			task.task,
			c_filename,
		),
	)
}

// ReadDataautoformat is wrapping [MSK_readdataautoformat]
//
// [MSK_readdataautoformat]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.readdataautoformat
func (task *Task) ReadDataautoformat(
	filename string,
) res.Code {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	return res.Code(
		C.MSK_readdataautoformat(
			task.task,
			c_filename,
		),
	)
}

// ReadDataformat is wrapping [MSK_readdataformat],
// Reads problem data from a file.
//
// Arguments:
//
//   - `filename` A valid file name.
//   - `format` File data format.
//   - `compress` File compression type.
//
// [MSK_readdataformat]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.readdataformat
func (task *Task) ReadDataformat(
	filename string,
	format DataFormat,
	compress CompressType,
) res.Code {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	return res.Code(
		C.MSK_readdataformat(
			task.task,
			c_filename,
			C.MSKdataformate(format),
			C.MSKcompresstypee(compress),
		),
	)
}

// ReadJsonsol is wrapping [MSK_readjsonsol],
// Reads a solution from a JSOL file.
//
// Arguments:
//
//   - `filename` A valid file name.
//
// [MSK_readjsonsol]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.readjsonsol
func (task *Task) ReadJsonsol(
	filename string,
) res.Code {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	return res.Code(
		C.MSK_readjsonsol(
			task.task,
			c_filename,
		),
	)
}

// ReadJsonstring is wrapping [MSK_readjsonstring],
// Load task data from a string in JSON format.
//
// Arguments:
//
//   - `data` Problem data in text format.
//
// [MSK_readjsonstring]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.readjsonstring
func (task *Task) ReadJsonstring(
	data string,
) res.Code {
	c_data := C.CString(data)
	defer C.free(unsafe.Pointer(c_data))

	return res.Code(
		C.MSK_readjsonstring(
			task.task,
			c_data,
		),
	)
}

// ReadLpstring is wrapping [MSK_readlpstring],
// Load task data from a string in LP format.
//
// Arguments:
//
//   - `data` Problem data in text format.
//
// [MSK_readlpstring]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.readlpstring
func (task *Task) ReadLpstring(
	data string,
) res.Code {
	c_data := C.CString(data)
	defer C.free(unsafe.Pointer(c_data))

	return res.Code(
		C.MSK_readlpstring(
			task.task,
			c_data,
		),
	)
}

// ReadOpfstring is wrapping [MSK_readopfstring],
// Load task data from a string in OPF format.
//
// Arguments:
//
//   - `data` Problem data in text format.
//
// [MSK_readopfstring]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.readopfstring
func (task *Task) ReadOpfstring(
	data string,
) res.Code {
	c_data := C.CString(data)
	defer C.free(unsafe.Pointer(c_data))

	return res.Code(
		C.MSK_readopfstring(
			task.task,
			c_data,
		),
	)
}

// ReadParamFile is wrapping [MSK_readparamfile],
// Reads a parameter file.
//
// Arguments:
//
//   - `filename` A valid file name.
//
// [MSK_readparamfile]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.readparamfile
func (task *Task) ReadParamFile(
	filename string,
) res.Code {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	return res.Code(
		C.MSK_readparamfile(
			task.task,
			c_filename,
		),
	)
}

// ReadPtfstring is wrapping [MSK_readptfstring],
// Load task data from a string in PTF format.
//
// Arguments:
//
//   - `data` Problem data in text format.
//
// [MSK_readptfstring]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.readptfstring
func (task *Task) ReadPtfstring(
	data string,
) res.Code {
	c_data := C.CString(data)
	defer C.free(unsafe.Pointer(c_data))

	return res.Code(
		C.MSK_readptfstring(
			task.task,
			c_data,
		),
	)
}

// ReadSolution is wrapping [MSK_readsolution],
// Reads a solution from a file.
//
// Arguments:
//
//   - `whichsol` Selects a solution.
//   - `filename` A valid file name.
//
// [MSK_readsolution]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.readsolution
func (task *Task) ReadSolution(
	whichsol SolType,
	filename string,
) res.Code {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	return res.Code(
		C.MSK_readsolution(
			task.task,
			C.MSKsoltypee(whichsol),
			c_filename,
		),
	)
}

// ReadSolutionFile is wrapping [MSK_readsolutionfile],
// Read solution file in format determined by the filename
//
// Arguments:
//
//   - `filename` A valid file name.
//
// [MSK_readsolutionfile]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.readsolutionfile
func (task *Task) ReadSolutionFile(
	filename string,
) res.Code {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	return res.Code(
		C.MSK_readsolutionfile(
			task.task,
			c_filename,
		),
	)
}

// ReadSummary is wrapping [MSK_readsummary],
// Prints information about last file read.
//
// Arguments:
//
//   - `whichstream` Index of the stream.
//
// [MSK_readsummary]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.readsummary
func (task *Task) ReadSummary(
	whichstream StreamType,
) res.Code {
	return res.Code(
		C.MSK_readsummary(
			task.task,
			C.MSKstreamtypee(whichstream),
		),
	)
}

// ReadTask is wrapping [MSK_readtask],
// Load task data from a file.
//
// Arguments:
//
//   - `filename` A valid file name.
//
// [MSK_readtask]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.readtask
func (task *Task) ReadTask(
	filename string,
) res.Code {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	return res.Code(
		C.MSK_readtask(
			task.task,
			c_filename,
		),
	)
}

// RemoveBarvars is wrapping [MSK_removebarvars],
// Removes a number of symmetric matrices.
//
// Arguments:
//
//   - `subset` Indexes of symmetric matrices which should be removed.
//
// [MSK_removebarvars]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.removebarvars
func (task *Task) RemoveBarvars(
	num int32,
	subset *int32,
) res.Code {
	return res.Code(
		C.MSK_removebarvars(
			task.task,
			C.MSKint32t(num),
			(*C.MSKint32t)(subset),
		),
	)
}

// RemoveCones is wrapping [MSK_removecones],
// Removes a number of conic constraints from the problem.
//
// Arguments:
//
//   - `subset` Indexes of cones which should be removed.
//
// Deprecated: [MSK_removecones]/RemoveCones is deprecated by mosek and will be removed in a future release.
//
// [MSK_removecones]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.removecones
func (task *Task) RemoveCones(
	num int32,
	subset *int32,
) res.Code {
	return res.Code(
		C.MSK_removecones(
			task.task,
			C.MSKint32t(num),
			(*C.MSKint32t)(subset),
		),
	)
}

// RemoveCons is wrapping [MSK_removecons],
// Removes a number of constraints.
//
// Arguments:
//
//   - `subset` Indexes of constraints which should be removed.
//
// [MSK_removecons]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.removecons
func (task *Task) RemoveCons(
	num int32,
	subset *int32,
) res.Code {
	return res.Code(
		C.MSK_removecons(
			task.task,
			C.MSKint32t(num),
			(*C.MSKint32t)(subset),
		),
	)
}

// RemoveVars is wrapping [MSK_removevars],
// Removes a number of variables.
//
// Arguments:
//
//   - `subset` Indexes of variables which should be removed.
//
// [MSK_removevars]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.removevars
func (task *Task) RemoveVars(
	num int32,
	subset *int32,
) res.Code {
	return res.Code(
		C.MSK_removevars(
			task.task,
			C.MSKint32t(num),
			(*C.MSKint32t)(subset),
		),
	)
}

// Resizetask is wrapping [MSK_resizetask],
// Resizes an optimization task.
//
// Arguments:
//
//   - `maxnumcon` New maximum number of constraints.
//   - `maxnumvar` New maximum number of variables.
//   - `maxnumcone` New maximum number of cones.
//   - `maxnumanz` New maximum number of linear non-zero elements.
//   - `maxnumqnz` New maximum number of quadratic non-zeros elements.
//
// [MSK_resizetask]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.resizetask
func (task *Task) Resizetask(
	maxnumcon int32,
	maxnumvar int32,
	maxnumcone int32,
	maxnumanz int64,
	maxnumqnz int64,
) res.Code {
	return res.Code(
		C.MSK_resizetask(
			task.task,
			C.MSKint32t(maxnumcon),
			C.MSKint32t(maxnumvar),
			C.MSKint32t(maxnumcone),
			C.MSKint64t(maxnumanz),
			C.MSKint64t(maxnumqnz),
		),
	)
}

// Sensitivityreport is wrapping [MSK_sensitivityreport],
// Creates a sensitivity report.
//
// Arguments:
//
//   - `whichstream` Index of the stream.
//
// [MSK_sensitivityreport]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.sensitivityreport
func (task *Task) Sensitivityreport(
	whichstream StreamType,
) res.Code {
	return res.Code(
		C.MSK_sensitivityreport(
			task.task,
			C.MSKstreamtypee(whichstream),
		),
	)
}

// SetDefaults is wrapping [MSK_setdefaults],
// Resets all parameter values.
//
// [MSK_setdefaults]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.setdefaults
func (task *Task) SetDefaults() res.Code {
	return res.Code(
		C.MSK_setdefaults(
			task.task,
		),
	)
}

// SkToStr is wrapping [MSK_sktostr]
//
// [MSK_sktostr]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.sktostr
func (task *Task) SkToStr(
	sk StaKey,
) (r res.Code, str string) {
	c_str := (*C.char)(C.calloc(MAX_STR_LEN+1, 1))
	defer C.free(unsafe.Pointer(c_str))

	r = res.Code(
		C.MSK_sktostr(
			task.task,
			C.MSKstakeye(sk),
			c_str,
		),
	)

	if r.IsOk() {
		str = C.GoString(c_str)
	}

	return
}

// SolStaToStr is wrapping [MSK_solstatostr]
//
// [MSK_solstatostr]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.solstatostr
func (task *Task) SolStaToStr(
	solutionsta SolSta,
) (r res.Code, str string) {
	c_str := (*C.char)(C.calloc(MAX_STR_LEN+1, 1))
	defer C.free(unsafe.Pointer(c_str))

	r = res.Code(
		C.MSK_solstatostr(
			task.task,
			C.MSKsolstae(solutionsta),
			c_str,
		),
	)

	if r.IsOk() {
		str = C.GoString(c_str)
	}

	return
}

// SolutionDef is wrapping [MSK_solutiondef],
// Checks whether a solution is defined.
//
// Arguments:
//
//   - `whichsol` Selects a solution.
//
// Returns:
//
//   - `isdef` Is non-zero if the requested solution is defined.
//
// [MSK_solutiondef]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.solutiondef
func (task *Task) SolutionDef(
	whichsol SolType,
) (r res.Code, isdef bool) {
	c_isdef := C.MSKbooleant(0)

	r = res.Code(
		C.MSK_solutiondef(
			task.task,
			C.MSKsoltypee(whichsol),
			&c_isdef,
		),
	)

	if r.IsOk() {
		isdef = intToBool(c_isdef)
	}

	return
}

// SolutionSummary is wrapping [MSK_solutionsummary],
// Prints a short summary of the current solutions.
//
// Arguments:
//
//   - `whichstream` Index of the stream.
//
// [MSK_solutionsummary]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.solutionsummary
func (task *Task) SolutionSummary(
	whichstream StreamType,
) res.Code {
	return res.Code(
		C.MSK_solutionsummary(
			task.task,
			C.MSKstreamtypee(whichstream),
		),
	)
}

// Solvewithbasis is wrapping [MSK_solvewithbasis],
// Solve a linear equation system involving a basis matrix.
//
// Arguments:
//
//   - `transp` Controls which problem formulation is solved.
//   - `numnz` Input (number of non-zeros in right-hand side).
//   - `sub` Input (indexes of non-zeros in right-hand side) and output (indexes of non-zeros in solution vector).
//   - `val` Input (right-hand side values) and output (solution vector values).
//
// Returns:
//
//   - `numnzout` Output (number of non-zeros in solution vector).
//
// [MSK_solvewithbasis]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.solvewithbasis
func (task *Task) Solvewithbasis(
	transp bool,
	numnz int32,
	sub *int32,
	val *float64,
	numnzout *int32,
) res.Code {
	return res.Code(
		C.MSK_solvewithbasis(
			task.task,
			boolToInt(transp),
			C.MSKint32t(numnz),
			(*C.MSKint32t)(sub),
			(*C.MSKrealt)(val),
			(*C.MSKint32t)(numnzout),
		),
	)
}

// Strtoconetype is wrapping [MSK_strtoconetype],
// Obtains a cone type code.
//
// Arguments:
//
//   - `str` String corresponding to the cone type code.
//   - `conetype` The cone type corresponding to str.
//
// Deprecated: [MSK_strtoconetype]/Strtoconetype is deprecated by mosek and will be removed in a future release.
//
// [MSK_strtoconetype]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.strtoconetype
func (task *Task) Strtoconetype(
	str string,
	conetype *ConeType,
) res.Code {
	c_str := C.CString(str)
	defer C.free(unsafe.Pointer(c_str))

	return res.Code(
		C.MSK_strtoconetype(
			task.task,
			c_str,
			(*C.MSKconetypee)(conetype),
		),
	)
}

// Strtosk is wrapping [MSK_strtosk],
// Obtains a status key.
//
// Arguments:
//
//   - `str` A status key abbreviation string.
//   - `sk` Status key corresponding to the string.
//
// [MSK_strtosk]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.strtosk
func (task *Task) Strtosk(
	str string,
	sk *StaKey,
) res.Code {
	c_str := C.CString(str)
	defer C.free(unsafe.Pointer(c_str))

	return res.Code(
		C.MSK_strtosk(
			task.task,
			c_str,
			(*C.MSKstakeye)(sk),
		),
	)
}

// Toconic is wrapping [MSK_toconic],
// In-place reformulation of a QCQO to a conic quadratic problem.
//
// Deprecated: [MSK_toconic]/Toconic is deprecated by mosek and will be removed in a future release.
//
// [MSK_toconic]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.toconic
func (task *Task) Toconic() res.Code {
	return res.Code(
		C.MSK_toconic(
			task.task,
		),
	)
}

// UnlinkFuncfromtaskstream is wrapping [MSK_unlinkfuncfromtaskstream]
//
// [MSK_unlinkfuncfromtaskstream]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.unlinkfuncfromtaskstream
func (task *Task) UnlinkFuncfromtaskstream(
	whichstream StreamType,
) res.Code {
	return res.Code(
		C.MSK_unlinkfuncfromtaskstream(
			task.task,
			C.MSKstreamtypee(whichstream),
		),
	)
}

// UpdatesolutionInfo is wrapping [MSK_updatesolutioninfo],
// Update the information items related to the solution.
//
// Arguments:
//
//   - `whichsol` Selects a solution.
//
// [MSK_updatesolutioninfo]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.updatesolutioninfo
func (task *Task) UpdatesolutionInfo(
	whichsol SolType,
) res.Code {
	return res.Code(
		C.MSK_updatesolutioninfo(
			task.task,
			C.MSKsoltypee(whichsol),
		),
	)
}

// Whichparam is wrapping [MSK_whichparam],
// Checks a parameter name.
//
// Arguments:
//
//   - `parname` Parameter name.
//   - `partype` Parameter type.
//   - `param` Which parameter.
//
// [MSK_whichparam]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.whichparam
func (task *Task) Whichparam(
	parname string,
	partype *ParameterType,
	param *int32,
) res.Code {
	c_parname := C.CString(parname)
	defer C.free(unsafe.Pointer(c_parname))

	return res.Code(
		C.MSK_whichparam(
			task.task,
			c_parname,
			(*C.MSKparametertypee)(partype),
			(*C.MSKint32t)(param),
		),
	)
}

// WriteBsolution is wrapping [MSK_writebsolution],
// Write a binary dump of the task solution and information items.
//
// Arguments:
//
//   - `filename` A valid file name.
//   - `compress` Data compression type.
//
// [MSK_writebsolution]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.writebsolution
func (task *Task) WriteBsolution(
	filename string,
	compress CompressType,
) res.Code {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	return res.Code(
		C.MSK_writebsolution(
			task.task,
			c_filename,
			C.MSKcompresstypee(compress),
		),
	)
}

// WriteData is wrapping [MSK_writedata],
// Writes problem data to a file.
//
// Arguments:
//
//   - `filename` A valid file name.
//
// [MSK_writedata]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.writedata
func (task *Task) WriteData(
	filename string,
) res.Code {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	return res.Code(
		C.MSK_writedata(
			task.task,
			c_filename,
		),
	)
}

// WriteJsonsol is wrapping [MSK_writejsonsol],
// Writes a solution to a JSON file.
//
// Arguments:
//
//   - `filename` A valid file name.
//
// [MSK_writejsonsol]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.writejsonsol
func (task *Task) WriteJsonsol(
	filename string,
) res.Code {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	return res.Code(
		C.MSK_writejsonsol(
			task.task,
			c_filename,
		),
	)
}

// WriteParamFile is wrapping [MSK_writeparamfile],
// Writes all the parameters to a parameter file.
//
// Arguments:
//
//   - `filename` A valid file name.
//
// [MSK_writeparamfile]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.writeparamfile
func (task *Task) WriteParamFile(
	filename string,
) res.Code {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	return res.Code(
		C.MSK_writeparamfile(
			task.task,
			c_filename,
		),
	)
}

// WriteSolution is wrapping [MSK_writesolution],
// Write a solution to a file.
//
// Arguments:
//
//   - `whichsol` Selects a solution.
//   - `filename` A valid file name.
//
// [MSK_writesolution]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.writesolution
func (task *Task) WriteSolution(
	whichsol SolType,
	filename string,
) res.Code {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	return res.Code(
		C.MSK_writesolution(
			task.task,
			C.MSKsoltypee(whichsol),
			c_filename,
		),
	)
}

// WriteSolutionFile is wrapping [MSK_writesolutionfile],
// Write solution file in format determined by the filename
//
// Arguments:
//
//   - `filename` A valid file name.
//
// [MSK_writesolutionfile]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.writesolutionfile
func (task *Task) WriteSolutionFile(
	filename string,
) res.Code {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	return res.Code(
		C.MSK_writesolutionfile(
			task.task,
			c_filename,
		),
	)
}

// WriteTask is wrapping [MSK_writetask],
// Write a complete binary dump of the task data.
//
// Arguments:
//
//   - `filename` A valid file name.
//
// [MSK_writetask]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.writetask
func (task *Task) WriteTask(
	filename string,
) res.Code {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	return res.Code(
		C.MSK_writetask(
			task.task,
			c_filename,
		),
	)
}
