// Automatically generated by github.com/fardream/gen-gmsk
// function deinitions

package gmsk

// #include <stdlib.h> // for C.free
// #include <mosek.h>
import "C"

import (
	"unsafe"

	"github.com/fardream/gmsk/res"
)

// PutAcc is wrapping [MSK_putacc],
// Puts an affine conic constraint.
//
// Arguments:
//
//   - `accidx` Affine conic constraint index.
//   - `domidx` Domain index.
//   - `afeidxlist` List of affine expression indexes.
//   - `b` The vector of constant terms added to affine expressions. Optional, can be NULL.
//
// [MSK_putacc]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putacc
func (task *Task) PutAcc(
	accidx int64,
	domidx int64,
	numafeidx int64,
	afeidxlist *int64,
	b *float64,
) res.Code {
	return res.Code(
		C.MSK_putacc(
			task.task,
			C.MSKint64t(accidx),
			C.MSKint64t(domidx),
			C.MSKint64t(numafeidx),
			(*C.MSKint64t)(afeidxlist),
			(*C.MSKrealt)(b),
		),
	)
}

// PutAccB is wrapping [MSK_putaccb],
// Puts the constant vector b in an affine conic constraint.
//
// Arguments:
//
//   - `accidx` Affine conic constraint index.
//   - `b` The vector of constant terms added to affine expressions. Optional, can be NULL.
//
// [MSK_putaccb]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putaccb
func (task *Task) PutAccB(
	accidx int64,
	lengthb int64,
	b *float64,
) res.Code {
	return res.Code(
		C.MSK_putaccb(
			task.task,
			C.MSKint64t(accidx),
			C.MSKint64t(lengthb),
			(*C.MSKrealt)(b),
		),
	)
}

// PutAccBJ is wrapping [MSK_putaccbj],
// Sets one element in the b vector of an affine conic constraint.
//
// Arguments:
//
//   - `accidx` Affine conic constraint index.
//   - `j` The index of an element in b to change.
//   - `bj` The new value of b\[j\].
//
// [MSK_putaccbj]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putaccbj
func (task *Task) PutAccBJ(
	accidx int64,
	j int64,
	bj float64,
) res.Code {
	return res.Code(
		C.MSK_putaccbj(
			task.task,
			C.MSKint64t(accidx),
			C.MSKint64t(j),
			C.MSKrealt(bj),
		),
	)
}

// PutAccDotY is wrapping [MSK_putaccdoty],
// Puts the doty vector for a solution.
//
// Arguments:
//
//   - `whichsol` Selects a solution.
//   - `accidx` The index of the affine conic constraint.
//   - `doty` The dual values for this affine conic constraint. The array should have length equal to the dimension of the constraint.
//
// [MSK_putaccdoty]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putaccdoty
func (task *Task) PutAccDotY(
	whichsol SolType,
	accidx int64,
	doty *float64,
) res.Code {
	return res.Code(
		C.MSK_putaccdoty(
			task.task,
			C.MSKsoltypee(whichsol),
			C.MSKint64t(accidx),
			(*C.MSKrealt)(doty),
		),
	)
}

// PutACol is wrapping [MSK_putacol],
// Replaces all elements in one column of the linear constraint matrix.
//
// Arguments:
//
//   - `j` Column index.
//   - `subj` Row indexes of non-zero values in column.
//   - `valj` New non-zero values of column.
//
// [MSK_putacol]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putacol
func (task *Task) PutACol(
	j int32,
	nzj int32,
	subj *int32,
	valj *float64,
) res.Code {
	return res.Code(
		C.MSK_putacol(
			task.task,
			C.MSKint32t(j),
			C.MSKint32t(nzj),
			(*C.MSKint32t)(subj),
			(*C.MSKrealt)(valj),
		),
	)
}

// PutAColSlice64 is wrapping [MSK_putacolslice64]
//
// [MSK_putacolslice64]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putacolslice64
func (task *Task) PutAColSlice64(
	first int32,
	last int32,
	ptrb *int64,
	ptre *int64,
	asub *int32,
	aval *float64,
) res.Code {
	return res.Code(
		C.MSK_putacolslice64(
			task.task,
			C.MSKint32t(first),
			C.MSKint32t(last),
			(*C.MSKint64t)(ptrb),
			(*C.MSKint64t)(ptre),
			(*C.MSKint32t)(asub),
			(*C.MSKrealt)(aval),
		),
	)
}

// PutAfeBarfBlockTriplet is wrapping [MSK_putafebarfblocktriplet],
// Inputs barF in block triplet form.
//
// Arguments:
//
//   - `afeidx` Constraint index.
//   - `barvaridx` Symmetric matrix variable index.
//   - `subk` Block row index.
//   - `subl` Block column index.
//   - `valkl` The numerical value associated with each block triplet.
//
// [MSK_putafebarfblocktriplet]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putafebarfblocktriplet
func (task *Task) PutAfeBarfBlockTriplet(
	numtrip int64,
	afeidx *int64,
	barvaridx *int32,
	subk *int32,
	subl *int32,
	valkl *float64,
) res.Code {
	return res.Code(
		C.MSK_putafebarfblocktriplet(
			task.task,
			C.MSKint64t(numtrip),
			(*C.MSKint64t)(afeidx),
			(*C.MSKint32t)(barvaridx),
			(*C.MSKint32t)(subk),
			(*C.MSKint32t)(subl),
			(*C.MSKrealt)(valkl),
		),
	)
}

// PutAfeBarfEntry is wrapping [MSK_putafebarfentry],
// Inputs one entry in barF.
//
// Arguments:
//
//   - `afeidx` Row index of barF.
//   - `barvaridx` Semidefinite variable index.
//   - `termidx` Element indices in matrix storage.
//   - `termweight` Weights in the weighted sum.
//
// [MSK_putafebarfentry]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putafebarfentry
func (task *Task) PutAfeBarfEntry(
	afeidx int64,
	barvaridx int32,
	numterm int64,
	termidx *int64,
	termweight *float64,
) res.Code {
	return res.Code(
		C.MSK_putafebarfentry(
			task.task,
			C.MSKint64t(afeidx),
			C.MSKint32t(barvaridx),
			C.MSKint64t(numterm),
			(*C.MSKint64t)(termidx),
			(*C.MSKrealt)(termweight),
		),
	)
}

// PutAfeBarfRow is wrapping [MSK_putafebarfrow],
// Inputs a row of barF.
//
// Arguments:
//
//   - `afeidx` Row index of barF.
//   - `barvaridx` Semidefinite variable indexes.
//   - `numterm` Number of terms in the weighted sums.
//   - `ptrterm` Pointer to the terms forming each entry.
//   - `termidx` Concatenated element indexes in matrix storage.
//   - `termweight` Concatenated weights in the weighted sum.
//
// [MSK_putafebarfrow]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putafebarfrow
func (task *Task) PutAfeBarfRow(
	afeidx int64,
	numentr int32,
	barvaridx *int32,
	numterm *int64,
	ptrterm *int64,
	lenterm int64,
	termidx *int64,
	termweight *float64,
) res.Code {
	return res.Code(
		C.MSK_putafebarfrow(
			task.task,
			C.MSKint64t(afeidx),
			C.MSKint32t(numentr),
			(*C.MSKint32t)(barvaridx),
			(*C.MSKint64t)(numterm),
			(*C.MSKint64t)(ptrterm),
			C.MSKint64t(lenterm),
			(*C.MSKint64t)(termidx),
			(*C.MSKrealt)(termweight),
		),
	)
}

// PutAfeFCol is wrapping [MSK_putafefcol],
// Replaces all elements in one column of the F matrix in the affine expressions.
//
// Arguments:
//
//   - `varidx` Column index.
//   - `afeidx` Row indexes of non-zero values in the column.
//   - `val` New non-zero values in the column.
//
// [MSK_putafefcol]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putafefcol
func (task *Task) PutAfeFCol(
	varidx int32,
	numnz int64,
	afeidx *int64,
	val *float64,
) res.Code {
	return res.Code(
		C.MSK_putafefcol(
			task.task,
			C.MSKint32t(varidx),
			C.MSKint64t(numnz),
			(*C.MSKint64t)(afeidx),
			(*C.MSKrealt)(val),
		),
	)
}

// PutAfeFEntry is wrapping [MSK_putafefentry],
// Replaces one entry in F.
//
// Arguments:
//
//   - `afeidx` Row index in F.
//   - `varidx` Column index in F.
//   - `value` Value of the entry.
//
// [MSK_putafefentry]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putafefentry
func (task *Task) PutAfeFEntry(
	afeidx int64,
	varidx int32,
	value float64,
) res.Code {
	return res.Code(
		C.MSK_putafefentry(
			task.task,
			C.MSKint64t(afeidx),
			C.MSKint32t(varidx),
			C.MSKrealt(value),
		),
	)
}

// PutAfeFRow is wrapping [MSK_putafefrow],
// Replaces all elements in one row of the F matrix in the affine expressions.
//
// Arguments:
//
//   - `afeidx` Row index.
//   - `varidx` Column indexes of non-zero values in the row.
//   - `val` New non-zero values in the row.
//
// [MSK_putafefrow]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putafefrow
func (task *Task) PutAfeFRow(
	afeidx int64,
	numnz int32,
	varidx *int32,
	val *float64,
) res.Code {
	return res.Code(
		C.MSK_putafefrow(
			task.task,
			C.MSKint64t(afeidx),
			C.MSKint32t(numnz),
			(*C.MSKint32t)(varidx),
			(*C.MSKrealt)(val),
		),
	)
}

// PutAfeG is wrapping [MSK_putafeg],
// Replaces one element in the g vector in the affine expressions.
//
// Arguments:
//
//   - `afeidx` Row index.
//   - `g` New value for the element of g.
//
// [MSK_putafeg]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putafeg
func (task *Task) PutAfeG(
	afeidx int64,
	g float64,
) res.Code {
	return res.Code(
		C.MSK_putafeg(
			task.task,
			C.MSKint64t(afeidx),
			C.MSKrealt(g),
		),
	)
}

// PutAij is wrapping [MSK_putaij],
// Changes a single value in the linear coefficient matrix.
//
// Arguments:
//
//   - `i` Constraint (row) index.
//   - `j` Variable (column) index.
//   - `aij` New coefficient.
//
// [MSK_putaij]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putaij
func (task *Task) PutAij(
	i int32,
	j int32,
	aij float64,
) res.Code {
	return res.Code(
		C.MSK_putaij(
			task.task,
			C.MSKint32t(i),
			C.MSKint32t(j),
			C.MSKrealt(aij),
		),
	)
}

// PutARow is wrapping [MSK_putarow],
// Replaces all elements in one row of the linear constraint matrix.
//
// Arguments:
//
//   - `i` Row index.
//   - `subi` Column indexes of non-zero values in row.
//   - `vali` New non-zero values of row.
//
// [MSK_putarow]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putarow
func (task *Task) PutARow(
	i int32,
	nzi int32,
	subi *int32,
	vali *float64,
) res.Code {
	return res.Code(
		C.MSK_putarow(
			task.task,
			C.MSKint32t(i),
			C.MSKint32t(nzi),
			(*C.MSKint32t)(subi),
			(*C.MSKrealt)(vali),
		),
	)
}

// PutARowSlice64 is wrapping [MSK_putarowslice64]
//
// [MSK_putarowslice64]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putarowslice64
func (task *Task) PutARowSlice64(
	first int32,
	last int32,
	ptrb *int64,
	ptre *int64,
	asub *int32,
	aval *float64,
) res.Code {
	return res.Code(
		C.MSK_putarowslice64(
			task.task,
			C.MSKint32t(first),
			C.MSKint32t(last),
			(*C.MSKint64t)(ptrb),
			(*C.MSKint64t)(ptre),
			(*C.MSKint32t)(asub),
			(*C.MSKrealt)(aval),
		),
	)
}

// PutATruncateTol is wrapping [MSK_putatruncatetol],
// Truncates all elements in A below a certain tolerance to zero.
//
// Arguments:
//
//   - `tolzero` Truncation tolerance.
//
// [MSK_putatruncatetol]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putatruncatetol
func (task *Task) PutATruncateTol(
	tolzero float64,
) res.Code {
	return res.Code(
		C.MSK_putatruncatetol(
			task.task,
			C.MSKrealt(tolzero),
		),
	)
}

// PutBaraBlockTriplet is wrapping [MSK_putbarablocktriplet],
// Inputs barA in block triplet form.
//
// Arguments:
//
//   - `subi` Constraint index.
//   - `subj` Symmetric matrix variable index.
//   - `subk` Block row index.
//   - `subl` Block column index.
//   - `valijkl` The numerical value associated with each block triplet.
//
// [MSK_putbarablocktriplet]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putbarablocktriplet
func (task *Task) PutBaraBlockTriplet(
	num int64,
	subi *int32,
	subj *int32,
	subk *int32,
	subl *int32,
	valijkl *float64,
) res.Code {
	return res.Code(
		C.MSK_putbarablocktriplet(
			task.task,
			C.MSKint64t(num),
			(*C.MSKint32t)(subi),
			(*C.MSKint32t)(subj),
			(*C.MSKint32t)(subk),
			(*C.MSKint32t)(subl),
			(*C.MSKrealt)(valijkl),
		),
	)
}

// PutBaraIj is wrapping [MSK_putbaraij],
// Inputs an element of barA.
//
// Arguments:
//
//   - `i` Row index of barA.
//   - `j` Column index of barA.
//   - `sub` Element indexes in matrix storage.
//   - `weights` Weights in the weighted sum.
//
// [MSK_putbaraij]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putbaraij
func (task *Task) PutBaraIj(
	i int32,
	j int32,
	num int64,
	sub *int64,
	weights *float64,
) res.Code {
	return res.Code(
		C.MSK_putbaraij(
			task.task,
			C.MSKint32t(i),
			C.MSKint32t(j),
			C.MSKint64t(num),
			(*C.MSKint64t)(sub),
			(*C.MSKrealt)(weights),
		),
	)
}

// PutBarcBlockTriplet is wrapping [MSK_putbarcblocktriplet],
// Inputs barC in block triplet form.
//
// Arguments:
//
//   - `subj` Symmetric matrix variable index.
//   - `subk` Block row index.
//   - `subl` Block column index.
//   - `valjkl` The numerical value associated with each block triplet.
//
// [MSK_putbarcblocktriplet]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putbarcblocktriplet
func (task *Task) PutBarcBlockTriplet(
	num int64,
	subj *int32,
	subk *int32,
	subl *int32,
	valjkl *float64,
) res.Code {
	return res.Code(
		C.MSK_putbarcblocktriplet(
			task.task,
			C.MSKint64t(num),
			(*C.MSKint32t)(subj),
			(*C.MSKint32t)(subk),
			(*C.MSKint32t)(subl),
			(*C.MSKrealt)(valjkl),
		),
	)
}

// PutBarcJ is wrapping [MSK_putbarcj],
// Changes one element in barc.
//
// Arguments:
//
//   - `j` Index of the element in barc` that should be changed.
//   - `sub` sub is list of indexes of those symmetric matrices appearing in sum.
//   - `weights` The weights of the terms in the weighted sum.
//
// [MSK_putbarcj]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putbarcj
func (task *Task) PutBarcJ(
	j int32,
	num int64,
	sub *int64,
	weights *float64,
) res.Code {
	return res.Code(
		C.MSK_putbarcj(
			task.task,
			C.MSKint32t(j),
			C.MSKint64t(num),
			(*C.MSKint64t)(sub),
			(*C.MSKrealt)(weights),
		),
	)
}

// PutBarsJ is wrapping [MSK_putbarsj],
// Sets the dual solution for a semidefinite variable.
//
// Arguments:
//
//   - `whichsol` Selects a solution.
//   - `j` Index of the semidefinite variable.
//   - `barsj` Value of the j'th variable of barx.
//
// [MSK_putbarsj]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putbarsj
func (task *Task) PutBarsJ(
	whichsol SolType,
	j int32,
	barsj *float64,
) res.Code {
	return res.Code(
		C.MSK_putbarsj(
			task.task,
			C.MSKsoltypee(whichsol),
			C.MSKint32t(j),
			(*C.MSKrealt)(barsj),
		),
	)
}

// PutBarxJ is wrapping [MSK_putbarxj],
// Sets the primal solution for a semidefinite variable.
//
// Arguments:
//
//   - `whichsol` Selects a solution.
//   - `j` Index of the semidefinite variable.
//   - `barxj` Value of the j'th variable of barx.
//
// [MSK_putbarxj]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putbarxj
func (task *Task) PutBarxJ(
	whichsol SolType,
	j int32,
	barxj *float64,
) res.Code {
	return res.Code(
		C.MSK_putbarxj(
			task.task,
			C.MSKsoltypee(whichsol),
			C.MSKint32t(j),
			(*C.MSKrealt)(barxj),
		),
	)
}

// PutCfix is wrapping [MSK_putcfix],
// Replaces the fixed term in the objective.
//
// Arguments:
//
//   - `cfix` Fixed term in the objective.
//
// [MSK_putcfix]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putcfix
func (task *Task) PutCfix(
	cfix float64,
) res.Code {
	return res.Code(
		C.MSK_putcfix(
			task.task,
			C.MSKrealt(cfix),
		),
	)
}

// PutCJ is wrapping [MSK_putcj],
// Modifies one linear coefficient in the objective.
//
// Arguments:
//
//   - `j` Index of the variable whose objective coefficient should be changed.
//   - `cj` New coefficient value.
//
// [MSK_putcj]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putcj
func (task *Task) PutCJ(
	j int32,
	cj float64,
) res.Code {
	return res.Code(
		C.MSK_putcj(
			task.task,
			C.MSKint32t(j),
			C.MSKrealt(cj),
		),
	)
}

// PutConBound is wrapping [MSK_putconbound],
// Changes the bound for one constraint.
//
// Arguments:
//
//   - `i` Index of the constraint.
//   - `bkc` New bound key.
//   - `blc` New lower bound.
//   - `buc` New upper bound.
//
// [MSK_putconbound]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putconbound
func (task *Task) PutConBound(
	i int32,
	bkc BoundKey,
	blc float64,
	buc float64,
) res.Code {
	return res.Code(
		C.MSK_putconbound(
			task.task,
			C.MSKint32t(i),
			C.MSKboundkeye(bkc),
			C.MSKrealt(blc),
			C.MSKrealt(buc),
		),
	)
}

// PutConBoundListConst is wrapping [MSK_putconboundlistconst],
// Changes the bounds of a list of constraints.
//
// Arguments:
//
//   - `sub` List of constraint indexes.
//   - `bkc` New bound key for all constraints in the list.
//   - `blc` New lower bound for all constraints in the list.
//   - `buc` New upper bound for all constraints in the list.
//
// [MSK_putconboundlistconst]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putconboundlistconst
func (task *Task) PutConBoundListConst(
	num int32,
	sub *int32,
	bkc BoundKey,
	blc float64,
	buc float64,
) res.Code {
	return res.Code(
		C.MSK_putconboundlistconst(
			task.task,
			C.MSKint32t(num),
			(*C.MSKint32t)(sub),
			C.MSKboundkeye(bkc),
			C.MSKrealt(blc),
			C.MSKrealt(buc),
		),
	)
}

// PutCone is wrapping [MSK_putcone],
// Replaces a conic constraint.
//
// Arguments:
//
//   - `k` Index of the cone.
//   - `ct` Specifies the type of the cone.
//   - `conepar` For the power cone it denotes the exponent alpha. For other cone types it is unused and can be set to 0.
//   - `submem` Variable subscripts of the members in the cone.
//
// Deprecated: [MSK_putcone]/PutCone is deprecated by mosek and will be removed in a future release.
//
// [MSK_putcone]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putcone
func (task *Task) PutCone(
	k int32,
	ct ConeType,
	conepar float64,
	nummem int32,
	submem *int32,
) res.Code {
	return res.Code(
		C.MSK_putcone(
			task.task,
			C.MSKint32t(k),
			C.MSKconetypee(ct),
			C.MSKrealt(conepar),
			C.MSKint32t(nummem),
			(*C.MSKint32t)(submem),
		),
	)
}

// PutConSolutionI is wrapping [MSK_putconsolutioni],
// Sets the primal and dual solution information for a single constraint.
//
// Arguments:
//
//   - `i` Index of the constraint.
//   - `whichsol` Selects a solution.
//   - `sk` Status key of the constraint.
//   - `x` Primal solution value of the constraint.
//   - `sl` Solution value of the dual variable associated with the lower bound.
//   - `su` Solution value of the dual variable associated with the upper bound.
//
// [MSK_putconsolutioni]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putconsolutioni
func (task *Task) PutConSolutionI(
	i int32,
	whichsol SolType,
	sk StaKey,
	x float64,
	sl float64,
	su float64,
) res.Code {
	return res.Code(
		C.MSK_putconsolutioni(
			task.task,
			C.MSKint32t(i),
			C.MSKsoltypee(whichsol),
			C.MSKstakeye(sk),
			C.MSKrealt(x),
			C.MSKrealt(sl),
			C.MSKrealt(su),
		),
	)
}

// PutDjc is wrapping [MSK_putdjc],
// Inputs a disjunctive constraint.
//
// Arguments:
//
//   - `djcidx` Index of the disjunctive constraint.
//   - `domidxlist` List of domain indexes.
//   - `afeidxlist` List of affine expression indexes.
//   - `b` The vector of constant terms added to affine expressions.
//   - `termsizelist` List of term sizes.
//
// [MSK_putdjc]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putdjc
func (task *Task) PutDjc(
	djcidx int64,
	numdomidx int64,
	domidxlist *int64,
	numafeidx int64,
	afeidxlist *int64,
	b *float64,
	numterms int64,
	termsizelist *int64,
) res.Code {
	return res.Code(
		C.MSK_putdjc(
			task.task,
			C.MSKint64t(djcidx),
			C.MSKint64t(numdomidx),
			(*C.MSKint64t)(domidxlist),
			C.MSKint64t(numafeidx),
			(*C.MSKint64t)(afeidxlist),
			(*C.MSKrealt)(b),
			C.MSKint64t(numterms),
			(*C.MSKint64t)(termsizelist),
		),
	)
}

// PutDouParam is wrapping [MSK_putdouparam],
// Sets a double parameter.
//
// Arguments:
//
//   - `param` Which parameter.
//   - `parvalue` Parameter value.
//
// [MSK_putdouparam]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putdouparam
func (task *Task) PutDouParam(
	param DParam,
	parvalue float64,
) res.Code {
	return res.Code(
		C.MSK_putdouparam(
			task.task,
			C.MSKdparame(param),
			C.MSKrealt(parvalue),
		),
	)
}

// PutIntParam is wrapping [MSK_putintparam],
// Sets an integer parameter.
//
// Arguments:
//
//   - `param` Which parameter.
//   - `parvalue` Parameter value.
//
// [MSK_putintparam]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putintparam
func (task *Task) PutIntParam(
	param IParam,
	parvalue int32,
) res.Code {
	return res.Code(
		C.MSK_putintparam(
			task.task,
			C.MSKiparame(param),
			C.MSKint32t(parvalue),
		),
	)
}

// PutNaDouParam is wrapping [MSK_putnadouparam],
// Sets a double parameter.
//
// Arguments:
//
//   - `paramname` Name of a parameter.
//   - `parvalue` Parameter value.
//
// [MSK_putnadouparam]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putnadouparam
func (task *Task) PutNaDouParam(
	paramname string,
	parvalue float64,
) res.Code {
	c_paramname := C.CString(paramname)
	defer C.free(unsafe.Pointer(c_paramname))

	return res.Code(
		C.MSK_putnadouparam(
			task.task,
			c_paramname,
			C.MSKrealt(parvalue),
		),
	)
}

// PutNaIntParam is wrapping [MSK_putnaintparam],
// Sets an integer parameter.
//
// Arguments:
//
//   - `paramname` Name of a parameter.
//   - `parvalue` Parameter value.
//
// [MSK_putnaintparam]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putnaintparam
func (task *Task) PutNaIntParam(
	paramname string,
	parvalue int32,
) res.Code {
	c_paramname := C.CString(paramname)
	defer C.free(unsafe.Pointer(c_paramname))

	return res.Code(
		C.MSK_putnaintparam(
			task.task,
			c_paramname,
			C.MSKint32t(parvalue),
		),
	)
}

// PutNaStrParam is wrapping [MSK_putnastrparam],
// Sets a string parameter.
//
// Arguments:
//
//   - `paramname` Name of a parameter.
//   - `parvalue` Parameter value.
//
// [MSK_putnastrparam]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putnastrparam
func (task *Task) PutNaStrParam(
	paramname string,
	parvalue string,
) res.Code {
	c_paramname := C.CString(paramname)
	defer C.free(unsafe.Pointer(c_paramname))

	c_parvalue := C.CString(parvalue)
	defer C.free(unsafe.Pointer(c_parvalue))

	return res.Code(
		C.MSK_putnastrparam(
			task.task,
			c_paramname,
			c_parvalue,
		),
	)
}

// PutObjSense is wrapping [MSK_putobjsense],
// Sets the objective sense.
//
// Arguments:
//
//   - `sense` The objective sense of the task
//
// [MSK_putobjsense]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putobjsense
func (task *Task) PutObjSense(
	sense ObjectiveSense,
) res.Code {
	return res.Code(
		C.MSK_putobjsense(
			task.task,
			C.MSKobjsensee(sense),
		),
	)
}

// PutOptserverHost is wrapping [MSK_putoptserverhost],
// Specify an OptServer for remote calls.
//
// Arguments:
//
//   - `host` A URL specifying the optimization server to be used.
//
// [MSK_putoptserverhost]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putoptserverhost
func (task *Task) PutOptserverHost(
	host string,
) res.Code {
	c_host := C.CString(host)
	defer C.free(unsafe.Pointer(c_host))

	return res.Code(
		C.MSK_putoptserverhost(
			task.task,
			c_host,
		),
	)
}

// PutParam is wrapping [MSK_putparam],
// Modifies the value of parameter.
//
// Arguments:
//
//   - `parname` Parameter name.
//   - `parvalue` Parameter value.
//
// [MSK_putparam]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putparam
func (task *Task) PutParam(
	parname string,
	parvalue string,
) res.Code {
	c_parname := C.CString(parname)
	defer C.free(unsafe.Pointer(c_parname))

	c_parvalue := C.CString(parvalue)
	defer C.free(unsafe.Pointer(c_parvalue))

	return res.Code(
		C.MSK_putparam(
			task.task,
			c_parname,
			c_parvalue,
		),
	)
}

// PutQCon is wrapping [MSK_putqcon],
// Replaces all quadratic terms in constraints.
//
// Arguments:
//
//   - `qcsubk` Constraint subscripts for quadratic coefficients.
//   - `qcsubi` Row subscripts for quadratic constraint matrix.
//   - `qcsubj` Column subscripts for quadratic constraint matrix.
//   - `qcval` Quadratic constraint coefficient values.
//
// [MSK_putqcon]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putqcon
func (task *Task) PutQCon(
	numqcnz int32,
	qcsubk *int32,
	qcsubi *int32,
	qcsubj *int32,
	qcval *float64,
) res.Code {
	return res.Code(
		C.MSK_putqcon(
			task.task,
			C.MSKint32t(numqcnz),
			(*C.MSKint32t)(qcsubk),
			(*C.MSKint32t)(qcsubi),
			(*C.MSKint32t)(qcsubj),
			(*C.MSKrealt)(qcval),
		),
	)
}

// PutQConK is wrapping [MSK_putqconk],
// Replaces all quadratic terms in a single constraint.
//
// Arguments:
//
//   - `k` The constraint in which the new quadratic elements are inserted.
//   - `qcsubi` Row subscripts for quadratic constraint matrix.
//   - `qcsubj` Column subscripts for quadratic constraint matrix.
//   - `qcval` Quadratic constraint coefficient values.
//
// [MSK_putqconk]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putqconk
func (task *Task) PutQConK(
	k int32,
	numqcnz int32,
	qcsubi *int32,
	qcsubj *int32,
	qcval *float64,
) res.Code {
	return res.Code(
		C.MSK_putqconk(
			task.task,
			C.MSKint32t(k),
			C.MSKint32t(numqcnz),
			(*C.MSKint32t)(qcsubi),
			(*C.MSKint32t)(qcsubj),
			(*C.MSKrealt)(qcval),
		),
	)
}

// PutQObj is wrapping [MSK_putqobj],
// Replaces all quadratic terms in the objective.
//
// Arguments:
//
//   - `qosubi` Row subscripts for quadratic objective coefficients.
//   - `qosubj` Column subscripts for quadratic objective coefficients.
//   - `qoval` Quadratic objective coefficient values.
//
// [MSK_putqobj]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putqobj
func (task *Task) PutQObj(
	numqonz int32,
	qosubi *int32,
	qosubj *int32,
	qoval *float64,
) res.Code {
	return res.Code(
		C.MSK_putqobj(
			task.task,
			C.MSKint32t(numqonz),
			(*C.MSKint32t)(qosubi),
			(*C.MSKint32t)(qosubj),
			(*C.MSKrealt)(qoval),
		),
	)
}

// PutQObjIJ is wrapping [MSK_putqobjij],
// Replaces one coefficient in the quadratic term in the objective.
//
// Arguments:
//
//   - `i` Row index for the coefficient to be replaced.
//   - `j` Column index for the coefficient to be replaced.
//   - `qoij` The new coefficient value.
//
// [MSK_putqobjij]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putqobjij
func (task *Task) PutQObjIJ(
	i int32,
	j int32,
	qoij float64,
) res.Code {
	return res.Code(
		C.MSK_putqobjij(
			task.task,
			C.MSKint32t(i),
			C.MSKint32t(j),
			C.MSKrealt(qoij),
		),
	)
}

// PutSkc is wrapping [MSK_putskc],
// Sets the status keys for the constraints.
//
// Arguments:
//
//   - `whichsol` Selects a solution.
//   - `skc` Status keys for the constraints.
//
// [MSK_putskc]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putskc
func (task *Task) PutSkc(
	whichsol SolType,
	skc *StaKey,
) res.Code {
	return res.Code(
		C.MSK_putskc(
			task.task,
			C.MSKsoltypee(whichsol),
			(*C.MSKstakeye)(skc),
		),
	)
}

// PutSkx is wrapping [MSK_putskx],
// Sets the status keys for the scalar variables.
//
// Arguments:
//
//   - `whichsol` Selects a solution.
//   - `skx` Status keys for the variables.
//
// [MSK_putskx]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putskx
func (task *Task) PutSkx(
	whichsol SolType,
	skx *StaKey,
) res.Code {
	return res.Code(
		C.MSK_putskx(
			task.task,
			C.MSKsoltypee(whichsol),
			(*C.MSKstakeye)(skx),
		),
	)
}

// PutSlc is wrapping [MSK_putslc],
// Sets the slc vector for a solution.
//
// Arguments:
//
//   - `whichsol` Selects a solution.
//   - `slc` Dual variables corresponding to the lower bounds on the constraints.
//
// [MSK_putslc]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putslc
func (task *Task) PutSlc(
	whichsol SolType,
	slc *float64,
) res.Code {
	return res.Code(
		C.MSK_putslc(
			task.task,
			C.MSKsoltypee(whichsol),
			(*C.MSKrealt)(slc),
		),
	)
}

// PutSlx is wrapping [MSK_putslx],
// Sets the slx vector for a solution.
//
// Arguments:
//
//   - `whichsol` Selects a solution.
//   - `slx` Dual variables corresponding to the lower bounds on the variables.
//
// [MSK_putslx]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putslx
func (task *Task) PutSlx(
	whichsol SolType,
	slx *float64,
) res.Code {
	return res.Code(
		C.MSK_putslx(
			task.task,
			C.MSKsoltypee(whichsol),
			(*C.MSKrealt)(slx),
		),
	)
}

// PutSnx is wrapping [MSK_putsnx],
// Sets the snx vector for a solution.
//
// Arguments:
//
//   - `whichsol` Selects a solution.
//   - `sux` Dual variables corresponding to the upper bounds on the variables.
//
// [MSK_putsnx]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putsnx
func (task *Task) PutSnx(
	whichsol SolType,
	sux *float64,
) res.Code {
	return res.Code(
		C.MSK_putsnx(
			task.task,
			C.MSKsoltypee(whichsol),
			(*C.MSKrealt)(sux),
		),
	)
}

// PutSolution is wrapping [MSK_putsolution],
// Inserts a solution.
//
// Arguments:
//
//   - `whichsol` Selects a solution.
//   - `skc` Status keys for the constraints.
//   - `skx` Status keys for the variables.
//   - `skn` Status keys for the conic constraints.
//   - `xc` Primal constraint solution.
//   - `xx` Primal variable solution.
//   - `y` Vector of dual variables corresponding to the constraints.
//   - `slc` Dual variables corresponding to the lower bounds on the constraints.
//   - `suc` Dual variables corresponding to the upper bounds on the constraints.
//   - `slx` Dual variables corresponding to the lower bounds on the variables.
//   - `sux` Dual variables corresponding to the upper bounds on the variables.
//   - `snx` Dual variables corresponding to the conic constraints on the variables.
//
// [MSK_putsolution]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putsolution
func (task *Task) PutSolution(
	whichsol SolType,
	skc *StaKey,
	skx *StaKey,
	skn *StaKey,
	xc *float64,
	xx *float64,
	y *float64,
	slc *float64,
	suc *float64,
	slx *float64,
	sux *float64,
	snx *float64,
) res.Code {
	return res.Code(
		C.MSK_putsolution(
			task.task,
			C.MSKsoltypee(whichsol),
			(*C.MSKstakeye)(skc),
			(*C.MSKstakeye)(skx),
			(*C.MSKstakeye)(skn),
			(*C.MSKrealt)(xc),
			(*C.MSKrealt)(xx),
			(*C.MSKrealt)(y),
			(*C.MSKrealt)(slc),
			(*C.MSKrealt)(suc),
			(*C.MSKrealt)(slx),
			(*C.MSKrealt)(sux),
			(*C.MSKrealt)(snx),
		),
	)
}

// PutSolutionNew is wrapping [MSK_putsolutionnew],
// Inserts a solution.
//
// Arguments:
//
//   - `whichsol` Selects a solution.
//   - `skc` Status keys for the constraints.
//   - `skx` Status keys for the variables.
//   - `skn` Status keys for the conic constraints.
//   - `xc` Primal constraint solution.
//   - `xx` Primal variable solution.
//   - `y` Vector of dual variables corresponding to the constraints.
//   - `slc` Dual variables corresponding to the lower bounds on the constraints.
//   - `suc` Dual variables corresponding to the upper bounds on the constraints.
//   - `slx` Dual variables corresponding to the lower bounds on the variables.
//   - `sux` Dual variables corresponding to the upper bounds on the variables.
//   - `snx` Dual variables corresponding to the conic constraints on the variables.
//   - `doty` Dual variables corresponding to affine conic constraints.
//
// [MSK_putsolutionnew]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putsolutionnew
func (task *Task) PutSolutionNew(
	whichsol SolType,
	skc *StaKey,
	skx *StaKey,
	skn *StaKey,
	xc *float64,
	xx *float64,
	y *float64,
	slc *float64,
	suc *float64,
	slx *float64,
	sux *float64,
	snx *float64,
	doty *float64,
) res.Code {
	return res.Code(
		C.MSK_putsolutionnew(
			task.task,
			C.MSKsoltypee(whichsol),
			(*C.MSKstakeye)(skc),
			(*C.MSKstakeye)(skx),
			(*C.MSKstakeye)(skn),
			(*C.MSKrealt)(xc),
			(*C.MSKrealt)(xx),
			(*C.MSKrealt)(y),
			(*C.MSKrealt)(slc),
			(*C.MSKrealt)(suc),
			(*C.MSKrealt)(slx),
			(*C.MSKrealt)(sux),
			(*C.MSKrealt)(snx),
			(*C.MSKrealt)(doty),
		),
	)
}

// PutSolutionYI is wrapping [MSK_putsolutionyi],
// Inputs the dual variable of a solution.
//
// Arguments:
//
//   - `i` Index of the dual variable.
//   - `whichsol` Selects a solution.
//   - `y` Solution value of the dual variable.
//
// [MSK_putsolutionyi]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putsolutionyi
func (task *Task) PutSolutionYI(
	i int32,
	whichsol SolType,
	y float64,
) res.Code {
	return res.Code(
		C.MSK_putsolutionyi(
			task.task,
			C.MSKint32t(i),
			C.MSKsoltypee(whichsol),
			C.MSKrealt(y),
		),
	)
}

// PutStrParam is wrapping [MSK_putstrparam],
// Sets a string parameter.
//
// Arguments:
//
//   - `param` Which parameter.
//   - `parvalue` Parameter value.
//
// [MSK_putstrparam]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putstrparam
func (task *Task) PutStrParam(
	param SParam,
	parvalue string,
) res.Code {
	c_parvalue := C.CString(parvalue)
	defer C.free(unsafe.Pointer(c_parvalue))

	return res.Code(
		C.MSK_putstrparam(
			task.task,
			C.MSKsparame(param),
			c_parvalue,
		),
	)
}

// PutSuc is wrapping [MSK_putsuc],
// Sets the suc vector for a solution.
//
// Arguments:
//
//   - `whichsol` Selects a solution.
//   - `suc` Dual variables corresponding to the upper bounds on the constraints.
//
// [MSK_putsuc]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putsuc
func (task *Task) PutSuc(
	whichsol SolType,
	suc *float64,
) res.Code {
	return res.Code(
		C.MSK_putsuc(
			task.task,
			C.MSKsoltypee(whichsol),
			(*C.MSKrealt)(suc),
		),
	)
}

// PutSux is wrapping [MSK_putsux],
// Sets the sux vector for a solution.
//
// Arguments:
//
//   - `whichsol` Selects a solution.
//   - `sux` Dual variables corresponding to the upper bounds on the variables.
//
// [MSK_putsux]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putsux
func (task *Task) PutSux(
	whichsol SolType,
	sux *float64,
) res.Code {
	return res.Code(
		C.MSK_putsux(
			task.task,
			C.MSKsoltypee(whichsol),
			(*C.MSKrealt)(sux),
		),
	)
}

// PutVarBound is wrapping [MSK_putvarbound],
// Changes the bounds for one variable.
//
// Arguments:
//
//   - `j` Index of the variable.
//   - `bkx` New bound key.
//   - `blx` New lower bound.
//   - `bux` New upper bound.
//
// [MSK_putvarbound]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putvarbound
func (task *Task) PutVarBound(
	j int32,
	bkx BoundKey,
	blx float64,
	bux float64,
) res.Code {
	return res.Code(
		C.MSK_putvarbound(
			task.task,
			C.MSKint32t(j),
			C.MSKboundkeye(bkx),
			C.MSKrealt(blx),
			C.MSKrealt(bux),
		),
	)
}

// PutVarBoundListConst is wrapping [MSK_putvarboundlistconst],
// Changes the bounds of a list of variables.
//
// Arguments:
//
//   - `sub` List of variable indexes.
//   - `bkx` New bound key for all variables in the list.
//   - `blx` New lower bound for all variables in the list.
//   - `bux` New upper bound for all variables in the list.
//
// [MSK_putvarboundlistconst]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putvarboundlistconst
func (task *Task) PutVarBoundListConst(
	num int32,
	sub *int32,
	bkx BoundKey,
	blx float64,
	bux float64,
) res.Code {
	return res.Code(
		C.MSK_putvarboundlistconst(
			task.task,
			C.MSKint32t(num),
			(*C.MSKint32t)(sub),
			C.MSKboundkeye(bkx),
			C.MSKrealt(blx),
			C.MSKrealt(bux),
		),
	)
}

// PutVarSolutionJ is wrapping [MSK_putvarsolutionj],
// Sets the primal and dual solution information for a single variable.
//
// Arguments:
//
//   - `j` Index of the variable.
//   - `whichsol` Selects a solution.
//   - `sk` Status key of the variable.
//   - `x` Primal solution value of the variable.
//   - `sl` Solution value of the dual variable associated with the lower bound.
//   - `su` Solution value of the dual variable associated with the upper bound.
//   - `sn` Solution value of the dual variable associated with the conic constraint.
//
// [MSK_putvarsolutionj]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putvarsolutionj
func (task *Task) PutVarSolutionJ(
	j int32,
	whichsol SolType,
	sk StaKey,
	x float64,
	sl float64,
	su float64,
	sn float64,
) res.Code {
	return res.Code(
		C.MSK_putvarsolutionj(
			task.task,
			C.MSKint32t(j),
			C.MSKsoltypee(whichsol),
			C.MSKstakeye(sk),
			C.MSKrealt(x),
			C.MSKrealt(sl),
			C.MSKrealt(su),
			C.MSKrealt(sn),
		),
	)
}

// PutVarType is wrapping [MSK_putvartype],
// Sets the variable type of one variable.
//
// Arguments:
//
//   - `j` Index of the variable.
//   - `vartype` The new variable type.
//
// [MSK_putvartype]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putvartype
func (task *Task) PutVarType(
	j int32,
	vartype VariableType,
) res.Code {
	return res.Code(
		C.MSK_putvartype(
			task.task,
			C.MSKint32t(j),
			C.MSKvariabletypee(vartype),
		),
	)
}

// PutXc is wrapping [MSK_putxc],
// Sets the xc vector for a solution.
//
// Arguments:
//
//   - `whichsol` Selects a solution.
//   - `xc` Primal constraint solution.
//
// [MSK_putxc]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putxc
func (task *Task) PutXc(
	whichsol SolType,
	xc *float64,
) res.Code {
	return res.Code(
		C.MSK_putxc(
			task.task,
			C.MSKsoltypee(whichsol),
			(*C.MSKrealt)(xc),
		),
	)
}

// PutXx is wrapping [MSK_putxx],
// Sets the xx vector for a solution.
//
// Arguments:
//
//   - `whichsol` Selects a solution.
//   - `xx` Primal variable solution.
//
// [MSK_putxx]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.putxx
func (task *Task) PutXx(
	whichsol SolType,
	xx *float64,
) res.Code {
	return res.Code(
		C.MSK_putxx(
			task.task,
			C.MSKsoltypee(whichsol),
			(*C.MSKrealt)(xx),
		),
	)
}

// PutY is wrapping [MSK_puty],
// Sets the y vector for a solution.
//
// Arguments:
//
//   - `whichsol` Selects a solution.
//   - `y` Vector of dual variables corresponding to the constraints.
//
// [MSK_puty]: https://docs.mosek.com/latest/capi/alphabetic-functionalities.html#mosek.task.puty
func (task *Task) PutY(
	whichsol SolType,
	y *float64,
) res.Code {
	return res.Code(
		C.MSK_puty(
			task.task,
			C.MSKsoltypee(whichsol),
			(*C.MSKrealt)(y),
		),
	)
}
