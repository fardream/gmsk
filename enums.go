// Automatically generated by github.com/fardream/gen-gmsk
// There are many enums in MOSEK, this consolidate everything here.

package gmsk

// Basindtype is MSKbasindtype_enum
//
// Basis identification
type Basindtype uint32

const (
	BI_NEVER       Basindtype = 0 // Never do basis identification.
	BI_ALWAYS      Basindtype = 1 // Basis identification is always performed even if the interior-point optimizer terminates abnormally.
	BI_NO_ERROR    Basindtype = 2 // Basis identification is performed if the interior-point optimizer terminates without an error.
	BI_IF_FEASIBLE Basindtype = 3 // Basis identification is not performed if the interior-point optimizer terminates with a problem status saying that the problem is primal or dual infeasible.
	BI_RESERVERED  Basindtype = 4 // Not currently in use.
)

// BoundKey is MSKboundkey_enum
//
// Bound keys
type BoundKey uint32

const (
	BK_LO BoundKey = 0 // The constraint or variable has a finite lower bound and an infinite upper bound.
	BK_UP BoundKey = 1 // The constraint or variable has an infinite lower bound and an finite upper bound.
	BK_FX BoundKey = 2 // The constraint or variable is fixed.
	BK_FR BoundKey = 3 // The constraint or variable is free.
	BK_RA BoundKey = 4 // The constraint or variable is ranged.
)

// Mark is MSKmark_enum
//
// Mark
type Mark uint32

const (
	MARK_LO Mark = 0 // The lower bound is selected for sensitivity analysis.
	MARK_UP Mark = 1 // The upper bound is selected for sensitivity analysis.
)

// Simdegen is MSKsimdegen_enum
//
// Degeneracy strategies
type Simdegen uint32

const (
	SIM_DEGEN_NONE       Simdegen = 0 // The simplex optimizer should use no degeneration strategy.
	SIM_DEGEN_FREE       Simdegen = 1 // The simplex optimizer chooses the degeneration strategy.
	SIM_DEGEN_AGGRESSIVE Simdegen = 2 // The simplex optimizer should use an aggressive degeneration strategy.
	SIM_DEGEN_MODERATE   Simdegen = 3 // The simplex optimizer should use a moderate degeneration strategy.
	SIM_DEGEN_MINIMUM    Simdegen = 4 // The simplex optimizer should use a minimum degeneration strategy.
)

// Transpose is MSKtranspose_enum
//
// Transposed matrix.
type Transpose uint32

const (
	TRANSPOSE_NO  Transpose = 0 // No transpose is applied.
	TRANSPOSE_YES Transpose = 1 // A transpose is applied.
)

// UpLo is MSKuplo_enum
//
// Triangular part of a symmetric matrix.
type UpLo uint32

const (
	UPLO_LO UpLo = 0 // Lower part.
	UPLO_UP UpLo = 1 // Upper part.
)

// SimReform is MSKsimreform_enum
//
// Problem reformulation.
type SimReform uint32

const (
	SIM_REFORMULATION_OFF        SimReform = 0 // Disallow the simplex optimizer to reformulate the problem.
	SIM_REFORMULATION_ON         SimReform = 1 // Allow the simplex optimizer to reformulate the problem.
	SIM_REFORMULATION_FREE       SimReform = 2 // The simplex optimizer can choose freely.
	SIM_REFORMULATION_AGGRESSIVE SimReform = 3 // The simplex optimizer should use an aggressive reformulation strategy.
)

// Simdupvec is MSKsimdupvec_enum
//
// Exploit duplicate columns.
type Simdupvec uint32

const (
	SIM_EXPLOIT_DUPVEC_OFF  Simdupvec = 0 // Disallow the simplex optimizer to exploit duplicated columns.
	SIM_EXPLOIT_DUPVEC_ON   Simdupvec = 1 // Allow the simplex optimizer to exploit duplicated columns.
	SIM_EXPLOIT_DUPVEC_FREE Simdupvec = 2 // The simplex optimizer can choose freely.
)

// Simhotstart is MSKsimhotstart_enum
//
// Hot-start type employed by the simplex optimizer
type Simhotstart uint32

const (
	SIM_HOTSTART_NONE        Simhotstart = 0 // The simplex optimizer performs a coldstart.
	SIM_HOTSTART_FREE        Simhotstart = 1 // The simplex optimize chooses the hot-start type.
	SIM_HOTSTART_STATUS_KEYS Simhotstart = 2 // Only the status keys of the constraints and variables are used to choose the type of hot-start.
)

// IntpntHotstart is MSKintpnthotstart_enum
//
// Hot-start type employed by the interior-point optimizers.
type IntpntHotstart uint32

const (
	INTPNT_HOTSTART_NONE        IntpntHotstart = 0 // The interior-point optimizer performs a coldstart.
	INTPNT_HOTSTART_PRIMAL      IntpntHotstart = 1 // The interior-point optimizer exploits the primal solution only.
	INTPNT_HOTSTART_DUAL        IntpntHotstart = 2 // The interior-point optimizer exploits the dual solution only.
	INTPNT_HOTSTART_PRIMAL_DUAL IntpntHotstart = 3 // The interior-point optimizer exploits both the primal and dual solution.
)

// Purify is MSKpurify_enum
//
// Solution purification employed optimizer.
type Purify uint32

const (
	PURIFY_NONE        Purify = 0 // The optimizer performs no solution purification.
	PURIFY_PRIMAL      Purify = 1 // The optimizer purifies the primal solution.
	PURIFY_DUAL        Purify = 2 // The optimizer purifies the dual solution.
	PURIFY_PRIMAL_DUAL Purify = 3 // The optimizer purifies both the primal and dual solution.
	PURIFY_AUTO        Purify = 4 // TBD
)

// CallbackCode is MSKcallbackcode_enum
//
// Progress callback codes
type CallbackCode uint32

const (
	CALLBACK_BEGIN_BI                 CallbackCode = 0  // The basis identification procedure has been started.
	CALLBACK_BEGIN_CONIC              CallbackCode = 1  // The callback function is called when the conic optimizer is started.
	CALLBACK_BEGIN_DUAL_BI            CallbackCode = 2  // The callback function is called from within the basis identification procedure when the dual phase is started.
	CALLBACK_BEGIN_DUAL_SENSITIVITY   CallbackCode = 3  // Dual sensitivity analysis is started.
	CALLBACK_BEGIN_DUAL_SETUP_BI      CallbackCode = 4  // The callback function is called when the dual BI phase is started.
	CALLBACK_BEGIN_DUAL_SIMPLEX       CallbackCode = 5  // The callback function is called when the dual simplex optimizer started.
	CALLBACK_BEGIN_DUAL_SIMPLEX_BI    CallbackCode = 6  // The callback function is called from within the basis identification procedure when the dual simplex clean-up phase is started.
	CALLBACK_BEGIN_INFEAS_ANA         CallbackCode = 7  // The callback function is called when the infeasibility analyzer is started.
	CALLBACK_BEGIN_INTPNT             CallbackCode = 8  // The callback function is called when the interior-point optimizer is started.
	CALLBACK_BEGIN_LICENSE_WAIT       CallbackCode = 9  // Begin waiting for license.
	CALLBACK_BEGIN_MIO                CallbackCode = 10 // The callback function is called when the mixed-integer optimizer is started.
	CALLBACK_BEGIN_OPTIMIZER          CallbackCode = 11 // The callback function is called when the optimizer is started.
	CALLBACK_BEGIN_PRESOLVE           CallbackCode = 12 // The callback function is called when the presolve is started.
	CALLBACK_BEGIN_PRIMAL_BI          CallbackCode = 13 // The callback function is called from within the basis identification procedure when the primal phase is started.
	CALLBACK_BEGIN_PRIMAL_REPAIR      CallbackCode = 14 // Begin primal feasibility repair.
	CALLBACK_BEGIN_PRIMAL_SENSITIVITY CallbackCode = 15 // Primal sensitivity analysis is started.
	CALLBACK_BEGIN_PRIMAL_SETUP_BI    CallbackCode = 16 // The callback function is called when the primal BI setup is started.
	CALLBACK_BEGIN_PRIMAL_SIMPLEX     CallbackCode = 17 // The callback function is called when the primal simplex optimizer is started.
	CALLBACK_BEGIN_PRIMAL_SIMPLEX_BI  CallbackCode = 18 // The callback function is called from within the basis identification procedure when the primal simplex clean-up phase is started.
	CALLBACK_BEGIN_QCQO_REFORMULATE   CallbackCode = 19 // Begin QCQO reformulation.
	CALLBACK_BEGIN_READ               CallbackCode = 20 // MOSEK has started reading a problem file.
	CALLBACK_BEGIN_ROOT_CUTGEN        CallbackCode = 21 // The callback function is called when root cut generation is started.
	CALLBACK_BEGIN_SIMPLEX            CallbackCode = 22 // The callback function is called when the simplex optimizer is started.
	CALLBACK_BEGIN_SIMPLEX_BI         CallbackCode = 23 // The callback function is called from within the basis identification procedure when the simplex clean-up phase is started.
	CALLBACK_BEGIN_SOLVE_ROOT_RELAX   CallbackCode = 24 // The callback function is called when solution of root relaxation is started.
	CALLBACK_BEGIN_TO_CONIC           CallbackCode = 25 // Begin conic reformulation.
	CALLBACK_BEGIN_WRITE              CallbackCode = 26 // MOSEK has started writing a problem file.
	CALLBACK_CONIC                    CallbackCode = 27 // The callback function is called from within the conic optimizer after the information database has been updated.
	CALLBACK_DUAL_SIMPLEX             CallbackCode = 28 // The callback function is called from within the dual simplex optimizer.
	CALLBACK_END_BI                   CallbackCode = 29 // The callback function is called when the basis identification procedure is terminated.
	CALLBACK_END_CONIC                CallbackCode = 30 // The callback function is called when the conic optimizer is terminated.
	CALLBACK_END_DUAL_BI              CallbackCode = 31 // The callback function is called from within the basis identification procedure when the dual phase is terminated.
	CALLBACK_END_DUAL_SENSITIVITY     CallbackCode = 32 // Dual sensitivity analysis is terminated.
	CALLBACK_END_DUAL_SETUP_BI        CallbackCode = 33 // The callback function is called when the dual BI phase is terminated.
	CALLBACK_END_DUAL_SIMPLEX         CallbackCode = 34 // The callback function is called when the dual simplex optimizer is terminated.
	CALLBACK_END_DUAL_SIMPLEX_BI      CallbackCode = 35 // The callback function is called from within the basis identification procedure when the dual clean-up phase is terminated.
	CALLBACK_END_INFEAS_ANA           CallbackCode = 36 // The callback function is called when the infeasibility analyzer is terminated.
	CALLBACK_END_INTPNT               CallbackCode = 37 // The callback function is called when the interior-point optimizer is terminated.
	CALLBACK_END_LICENSE_WAIT         CallbackCode = 38 // End waiting for license.
	CALLBACK_END_MIO                  CallbackCode = 39 // The callback function is called when the mixed-integer optimizer is terminated.
	CALLBACK_END_OPTIMIZER            CallbackCode = 40 // The callback function is called when the optimizer is terminated.
	CALLBACK_END_PRESOLVE             CallbackCode = 41 // The callback function is called when the presolve is completed.
	CALLBACK_END_PRIMAL_BI            CallbackCode = 42 // The callback function is called from within the basis identification procedure when the primal phase is terminated.
	CALLBACK_END_PRIMAL_REPAIR        CallbackCode = 43 // End primal feasibility repair.
	CALLBACK_END_PRIMAL_SENSITIVITY   CallbackCode = 44 // Primal sensitivity analysis is terminated.
	CALLBACK_END_PRIMAL_SETUP_BI      CallbackCode = 45 // The callback function is called when the primal BI setup is terminated.
	CALLBACK_END_PRIMAL_SIMPLEX       CallbackCode = 46 // The callback function is called when the primal simplex optimizer is terminated.
	CALLBACK_END_PRIMAL_SIMPLEX_BI    CallbackCode = 47 // The callback function is called from within the basis identification procedure when the primal clean-up phase is terminated.
	CALLBACK_END_QCQO_REFORMULATE     CallbackCode = 48 // End QCQO reformulation.
	CALLBACK_END_READ                 CallbackCode = 49 // MOSEK has finished reading a problem file.
	CALLBACK_END_ROOT_CUTGEN          CallbackCode = 50 // The callback function is called when root cut generation is terminated.
	CALLBACK_END_SIMPLEX              CallbackCode = 51 // The callback function is called when the simplex optimizer is terminated.
	CALLBACK_END_SIMPLEX_BI           CallbackCode = 52 // The callback function is called from within the basis identification procedure when the simplex clean-up phase is terminated.
	CALLBACK_END_SOLVE_ROOT_RELAX     CallbackCode = 53 // The callback function is called when solution of root relaxation is terminated.
	CALLBACK_END_TO_CONIC             CallbackCode = 54 // End conic reformulation.
	CALLBACK_END_WRITE                CallbackCode = 55 // MOSEK has finished writing a problem file.
	CALLBACK_IM_BI                    CallbackCode = 56 // The callback function is called from within the basis identification procedure at an intermediate point.
	CALLBACK_IM_CONIC                 CallbackCode = 57 // The callback function is called at an intermediate stage within the conic optimizer where the information database has not been updated.
	CALLBACK_IM_DUAL_BI               CallbackCode = 58 // The callback function is called from within the basis identification procedure at an intermediate point in the dual phase.
	CALLBACK_IM_DUAL_SENSIVITY        CallbackCode = 59 // The callback function is called at an intermediate stage of the dual sensitivity analysis.
	CALLBACK_IM_DUAL_SIMPLEX          CallbackCode = 60 // The callback function is called at an intermediate point in the dual simplex optimizer.
	CALLBACK_IM_INTPNT                CallbackCode = 61 // The callback function is called at an intermediate stage within the interior-point optimizer where the information database has not been updated.
	CALLBACK_IM_LICENSE_WAIT          CallbackCode = 62 // MOSEK is waiting for a license.
	CALLBACK_IM_LU                    CallbackCode = 63 // The callback function is called from within the LU factorization procedure at an intermediate point.
	CALLBACK_IM_MIO                   CallbackCode = 64 // The callback function is called at an intermediate point in the mixed-integer optimizer.
	CALLBACK_IM_MIO_DUAL_SIMPLEX      CallbackCode = 65 // The callback function is called at an intermediate point in the mixed-integer optimizer while running the dual simplex optimizer.
	CALLBACK_IM_MIO_INTPNT            CallbackCode = 66 // The callback function is called at an intermediate point in the mixed-integer optimizer while running the interior-point optimizer.
	CALLBACK_IM_MIO_PRIMAL_SIMPLEX    CallbackCode = 67 // The callback function is called at an intermediate point in the mixed-integer optimizer while running the primal simplex optimizer.
	CALLBACK_IM_ORDER                 CallbackCode = 68 // The callback function is called from within the matrix ordering procedure at an intermediate point.
	CALLBACK_IM_PRESOLVE              CallbackCode = 69 // The callback function is called from within the presolve procedure at an intermediate stage.
	CALLBACK_IM_PRIMAL_BI             CallbackCode = 70 // The callback function is called from within the basis identification procedure at an intermediate point in the primal phase.
	CALLBACK_IM_PRIMAL_SENSIVITY      CallbackCode = 71 // The callback function is called at an intermediate stage of the primal sensitivity analysis.
	CALLBACK_IM_PRIMAL_SIMPLEX        CallbackCode = 72 // The callback function is called at an intermediate point in the primal simplex optimizer.
	CALLBACK_IM_QO_REFORMULATE        CallbackCode = 73 // The callback function is called at an intermediate stage of the conic quadratic reformulation.
	CALLBACK_IM_READ                  CallbackCode = 74 // Intermediate stage in reading.
	CALLBACK_IM_ROOT_CUTGEN           CallbackCode = 75 // The callback is called from within root cut generation at an intermediate stage.
	CALLBACK_IM_SIMPLEX               CallbackCode = 76 // The callback function is called from within the simplex optimizer at an intermediate point.
	CALLBACK_IM_SIMPLEX_BI            CallbackCode = 77 // The callback function is called from within the basis identification procedure at an intermediate point in the simplex clean-up phase.
	CALLBACK_INTPNT                   CallbackCode = 78 // The callback function is called from within the interior-point optimizer after the information database has been updated.
	CALLBACK_NEW_INT_MIO              CallbackCode = 79 // The callback function is called after a new integer solution has been located by the mixed-integer optimizer.
	CALLBACK_PRIMAL_SIMPLEX           CallbackCode = 80 // The callback function is called from within the primal simplex optimizer.
	CALLBACK_READ_OPF                 CallbackCode = 81 // The callback function is called from the OPF reader.
	CALLBACK_READ_OPF_SECTION         CallbackCode = 82 // A chunk of Q non-zeros has been read from a problem file.
	CALLBACK_SOLVING_REMOTE           CallbackCode = 83 // The callback function is called while the task is being solved on a remote server.
	CALLBACK_UPDATE_DUAL_BI           CallbackCode = 84 // The callback function is called from within the basis identification procedure at an intermediate point in the dual phase.
	CALLBACK_UPDATE_DUAL_SIMPLEX      CallbackCode = 85 // The callback function is called in the dual simplex optimizer.
	CALLBACK_UPDATE_DUAL_SIMPLEX_BI   CallbackCode = 86 // The callback function is called from within the basis identification procedure at an intermediate point in the dual simplex clean-up phase.
	CALLBACK_UPDATE_PRESOLVE          CallbackCode = 87 // The callback function is called from within the presolve procedure.
	CALLBACK_UPDATE_PRIMAL_BI         CallbackCode = 88 // The callback function is called from within the basis identification procedure at an intermediate point in the primal phase.
	CALLBACK_UPDATE_PRIMAL_SIMPLEX    CallbackCode = 89 // The callback function is called  in the primal simplex optimizer.
	CALLBACK_UPDATE_PRIMAL_SIMPLEX_BI CallbackCode = 90 // The callback function is called from within the basis identification procedure at an intermediate point in the primal simplex clean-up phase.
	CALLBACK_UPDATE_SIMPLEX           CallbackCode = 91 // The callback function is called from simplex optimizer.
	CALLBACK_WRITE_OPF                CallbackCode = 92 // The callback function is called from the OPF writer.
)

// CheckConvexityType is MSKcheckconvexitytype_enum
//
// Types of convexity checks.
type CheckConvexityType uint32

const (
	CHECK_CONVEXITY_NONE   CheckConvexityType = 0 // No convexity check.
	CHECK_CONVEXITY_SIMPLE CheckConvexityType = 1 // Perform simple and fast convexity check.
	CHECK_CONVEXITY_FULL   CheckConvexityType = 2 // Perform a full convexity check.
)

// CompressType is MSKcompresstype_enum
//
// Compression types
type CompressType uint32

const (
	COMPRESS_NONE CompressType = 0 // No compression is used.
	COMPRESS_FREE CompressType = 1 // The type of compression used is chosen automatically.
	COMPRESS_GZIP CompressType = 2 // The type of compression used is gzip compatible.
	COMPRESS_ZSTD CompressType = 3 // The type of compression used is zstd compatible.
)

// ConeType is MSKconetype_enum
//
// Cone types
type ConeType uint32

const (
	CT_QUAD  ConeType = 0 // The cone is a quadratic cone.
	CT_RQUAD ConeType = 1 // The cone is a rotated quadratic cone.
	CT_PEXP  ConeType = 2 // A primal exponential cone.
	CT_DEXP  ConeType = 3 // A dual exponential cone.
	CT_PPOW  ConeType = 4 // A primal power cone.
	CT_DPOW  ConeType = 5 // A dual power cone.
	CT_ZERO  ConeType = 6 // The zero cone.
)

// DomainType is MSKdomaintype_enum
//
// Cone types
type DomainType uint32

const (
	DOMAIN_R                    DomainType = 0  // R.
	DOMAIN_RZERO                DomainType = 1  // The zero vector.
	DOMAIN_RPLUS                DomainType = 2  // The positive orthant.
	DOMAIN_RMINUS               DomainType = 3  // The negative orthant.
	DOMAIN_QUADRATIC_CONE       DomainType = 4  // The quadratic cone.
	DOMAIN_RQUADRATIC_CONE      DomainType = 5  // The rotated quadratic cone.
	DOMAIN_PRIMAL_EXP_CONE      DomainType = 6  // The primal exponential cone.
	DOMAIN_DUAL_EXP_CONE        DomainType = 7  // The dual exponential cone.
	DOMAIN_PRIMAL_POWER_CONE    DomainType = 8  // The primal power cone.
	DOMAIN_DUAL_POWER_CONE      DomainType = 9  // The dual power cone.
	DOMAIN_PRIMAL_GEO_MEAN_CONE DomainType = 10 // The primal geometric mean cone.
	DOMAIN_DUAL_GEO_MEAN_CONE   DomainType = 11 // The dual geometric mean cone.
	DOMAIN_SVEC_PSD_CONE        DomainType = 12 // The vectorized positive semidefinite cone.
)

// NameType is MSKnametype_enum
//
// Name types
type NameType uint32

const (
	NAME_TYPE_GEN NameType = 0 // General names. However, no duplicate and blank names are allowed.
	NAME_TYPE_MPS NameType = 1 // MPS type names.
	NAME_TYPE_LP  NameType = 2 // LP type names.
)

// SymmatType is MSKsymmattype_enum
//
// Cone types
type SymmatType uint32

const (
	SYMMAT_TYPE_SPARSE SymmatType = 0 // Sparse symmetric matrix.
)

// DataFormat is MSKdataformat_enum
//
// Data format types
type DataFormat uint32

const (
	DATA_FORMAT_EXTENSION DataFormat = 0 // The file extension is used to determine the data file format.
	DATA_FORMAT_MPS       DataFormat = 1 // The data file is MPS formatted.
	DATA_FORMAT_LP        DataFormat = 2 // The data file is LP formatted.
	DATA_FORMAT_OP        DataFormat = 3 // The data file is an optimization problem formatted file.
	DATA_FORMAT_FREE_MPS  DataFormat = 4 // The data a free MPS formatted file.
	DATA_FORMAT_TASK      DataFormat = 5 // Generic task dump file.
	DATA_FORMAT_PTF       DataFormat = 6 // (P)retty (T)ext (F)format.
	DATA_FORMAT_CB        DataFormat = 7 // Conic benchmark format,
	DATA_FORMAT_JSON_TASK DataFormat = 8 // JSON based task format.
)

// SolFormat is MSKsolformat_enum
//
// Data format types
type SolFormat uint32

const (
	SOL_FORMAT_EXTENSION SolFormat = 0 // The file extension is used to determine the data file format.
	SOL_FORMAT_B         SolFormat = 1 // Simple binary format
	SOL_FORMAT_TASK      SolFormat = 2 // Tar based format.
	SOL_FORMAT_JSON_TASK SolFormat = 3 // JSON based format.
)

// DInfItem is MSKdinfitem_enum
//
// Double information items
type DInfItem uint32

const (
	DINF_ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_DENSITY   DInfItem = 0   // Density percentage of the scalarized constraint matrix.
	DINF_BI_CLEAN_DUAL_TIME                             DInfItem = 1   // Time  spent within the dual clean-up optimizer of the basis identification procedure since its invocation.
	DINF_BI_CLEAN_PRIMAL_TIME                           DInfItem = 2   // Time spent within the primal clean-up optimizer of the basis identification procedure since its invocation.
	DINF_BI_CLEAN_TIME                                  DInfItem = 3   // Time spent within the clean-up phase of the basis identification procedure since its invocation.
	DINF_BI_DUAL_TIME                                   DInfItem = 4   // Time spent within the dual phase basis identification procedure since its invocation.
	DINF_BI_PRIMAL_TIME                                 DInfItem = 5   // Time  spent within the primal phase of the basis identification procedure since its invocation.
	DINF_BI_TIME                                        DInfItem = 6   // Time spent within the basis identification procedure since its invocation.
	DINF_INTPNT_DUAL_FEAS                               DInfItem = 7   // Dual feasibility measure reported by the interior-point optimizer.
	DINF_INTPNT_DUAL_OBJ                                DInfItem = 8   // Dual objective value reported by the interior-point optimizer.
	DINF_INTPNT_FACTOR_NUM_FLOPS                        DInfItem = 9   // An estimate of the number of flops used in the factorization.
	DINF_INTPNT_OPT_STATUS                              DInfItem = 10  // A measure of optimality of the solution.
	DINF_INTPNT_ORDER_TIME                              DInfItem = 11  // Order time (in seconds).
	DINF_INTPNT_PRIMAL_FEAS                             DInfItem = 12  // Primal feasibility measure reported by the interior-point optimizer.
	DINF_INTPNT_PRIMAL_OBJ                              DInfItem = 13  // Primal objective value reported by the interior-point optimizer.
	DINF_INTPNT_TIME                                    DInfItem = 14  // Time spent within the interior-point optimizer since its invocation.
	DINF_MIO_CLIQUE_SEPARATION_TIME                     DInfItem = 15  // Separation time for clique cuts.
	DINF_MIO_CMIR_SEPARATION_TIME                       DInfItem = 16  // Separation time for CMIR cuts.
	DINF_MIO_CONSTRUCT_SOLUTION_OBJ                     DInfItem = 17  // Optimal objective value corresponding to the feasible solution.
	DINF_MIO_DUAL_BOUND_AFTER_PRESOLVE                  DInfItem = 18  // Value of the dual bound after presolve but before cut generation.
	DINF_MIO_GMI_SEPARATION_TIME                        DInfItem = 19  // Separation time for GMI cuts.
	DINF_MIO_IMPLIED_BOUND_TIME                         DInfItem = 20  // Separation time for implied bound cuts.
	DINF_MIO_INITIAL_FEASIBLE_SOLUTION_OBJ              DInfItem = 21  // Optimal objective value corresponding to the user provided initial solution.
	DINF_MIO_KNAPSACK_COVER_SEPARATION_TIME             DInfItem = 22  // Separation time for knapsack cover.
	DINF_MIO_LIPRO_SEPARATION_TIME                      DInfItem = 23  // Separation time for lift-and-project cuts.
	DINF_MIO_OBJ_ABS_GAP                                DInfItem = 24  // If the mixed-integer optimizer has computed a feasible solution and a bound, this contains the absolute gap.
	DINF_MIO_OBJ_BOUND                                  DInfItem = 25  // The best bound on the objective value known.
	DINF_MIO_OBJ_INT                                    DInfItem = 26  // The primal objective value corresponding to the best integer feasible solution.
	DINF_MIO_OBJ_REL_GAP                                DInfItem = 27  // If the mixed-integer optimizer has computed a feasible solution and a bound, this contains the relative gap.
	DINF_MIO_PROBING_TIME                               DInfItem = 28  // Total time for probing.
	DINF_MIO_ROOT_CUTGEN_TIME                           DInfItem = 29  // Total time for cut generation.
	DINF_MIO_ROOT_OPTIMIZER_TIME                        DInfItem = 30  // Time spent in the contiuous optimizer while processing the root node relaxation.
	DINF_MIO_ROOT_PRESOLVE_TIME                         DInfItem = 31  // Time spent presolving the problem at the root node.
	DINF_MIO_ROOT_TIME                                  DInfItem = 32  // Time spent processing the root node.
	DINF_MIO_TIME                                       DInfItem = 33  // Time spent in the mixed-integer optimizer.
	DINF_MIO_USER_OBJ_CUT                               DInfItem = 34  // If the objective cut is used, then this information item has the value of the cut.
	DINF_OPTIMIZER_TIME                                 DInfItem = 35  // Total time spent in the optimizer since it was invoked.
	DINF_PRESOLVE_ELI_TIME                              DInfItem = 36  // Total time spent in the eliminator since the presolve was invoked.
	DINF_PRESOLVE_LINDEP_TIME                           DInfItem = 37  // Total time spent  in the linear dependency checker since the presolve was invoked.
	DINF_PRESOLVE_TIME                                  DInfItem = 38  // Total time (in seconds) spent in the presolve since it was invoked.
	DINF_PRESOLVE_TOTAL_PRIMAL_PERTURBATION             DInfItem = 39  // Total perturbation of the bounds of the primal problem.
	DINF_PRIMAL_REPAIR_PENALTY_OBJ                      DInfItem = 40  // The optimal objective value of the penalty function.
	DINF_QCQO_REFORMULATE_MAX_PERTURBATION              DInfItem = 41  // Maximum absolute diagonal perturbation occurring during the QCQO reformulation.
	DINF_QCQO_REFORMULATE_TIME                          DInfItem = 42  // Time spent with conic quadratic reformulation.
	DINF_QCQO_REFORMULATE_WORST_CHOLESKY_COLUMN_SCALING DInfItem = 43  // Worst Cholesky column scaling.
	DINF_QCQO_REFORMULATE_WORST_CHOLESKY_DIAG_SCALING   DInfItem = 44  // Worst Cholesky diagonal scaling.
	DINF_READ_DATA_TIME                                 DInfItem = 45  // Time spent reading the data file.
	DINF_REMOTE_TIME                                    DInfItem = 46  // The total real time in seconds spent when optimizing on a server by the process performing the optimization on the server
	DINF_SIM_DUAL_TIME                                  DInfItem = 47  // Time spent in the dual simplex optimizer since invoking it.
	DINF_SIM_FEAS                                       DInfItem = 48  // Feasibility measure reported by the simplex optimizer.
	DINF_SIM_OBJ                                        DInfItem = 49  // Objective value reported by the simplex optimizer.
	DINF_SIM_PRIMAL_TIME                                DInfItem = 50  // Time spent in the primal simplex optimizer since invoking it.
	DINF_SIM_TIME                                       DInfItem = 51  // Time spent in the simplex optimizer since invoking it.
	DINF_SOL_BAS_DUAL_OBJ                               DInfItem = 52  // Dual objective value of the basic solution. Updated by the function updatesolutioninfo.
	DINF_SOL_BAS_DVIOLCON                               DInfItem = 53  // Maximal dual bound violation for xx in the basic solution. Updated by the function updatesolutioninfo.
	DINF_SOL_BAS_DVIOLVAR                               DInfItem = 54  // Maximal dual bound violation for xx in the basic solution. Updated by the function updatesolutioninfo.
	DINF_SOL_BAS_NRM_BARX                               DInfItem = 55  // Infinity norm of barx in the basic solution.
	DINF_SOL_BAS_NRM_SLC                                DInfItem = 56  // Infinity norm of slc in the basic solution.
	DINF_SOL_BAS_NRM_SLX                                DInfItem = 57  // Infinity norm of slx in the basic solution.
	DINF_SOL_BAS_NRM_SUC                                DInfItem = 58  // Infinity norm of suc in the basic solution.
	DINF_SOL_BAS_NRM_SUX                                DInfItem = 59  // Infinity norm of sux in the basic solution.
	DINF_SOL_BAS_NRM_XC                                 DInfItem = 60  // Infinity norm of xc in the basic solution.
	DINF_SOL_BAS_NRM_XX                                 DInfItem = 61  // Infinity norm of xx in the basic solution.
	DINF_SOL_BAS_NRM_Y                                  DInfItem = 62  // Infinity norm of Y in the basic solution.
	DINF_SOL_BAS_PRIMAL_OBJ                             DInfItem = 63  // Primal objective value of the basic solution. Updated by the function updatesolutioninfo.
	DINF_SOL_BAS_PVIOLCON                               DInfItem = 64  // Maximal primal bound violation for xc in the basic solution. Updated by the function updatesolutioninfo.
	DINF_SOL_BAS_PVIOLVAR                               DInfItem = 65  // Maximal primal bound violation for xx in the basic solution. Updated by the function updatesolutioninfo.
	DINF_SOL_ITG_NRM_BARX                               DInfItem = 66  // Infinity norm of barx in the integer solution.
	DINF_SOL_ITG_NRM_XC                                 DInfItem = 67  // Infinity norm of xc in the integer solution.
	DINF_SOL_ITG_NRM_XX                                 DInfItem = 68  // Infinity norm of xx in the integer solution.
	DINF_SOL_ITG_PRIMAL_OBJ                             DInfItem = 69  // Primal objective value of the integer solution. Updated by the function updatesolutioninfo.
	DINF_SOL_ITG_PVIOLACC                               DInfItem = 70  // Maximal primal violation for affine conic constraints in the integer solution. Updated by the function updatesolutioninfo.
	DINF_SOL_ITG_PVIOLBARVAR                            DInfItem = 71  // Maximal primal bound violation for barx in the integer solution. Updated by the function updatesolutioninfo.
	DINF_SOL_ITG_PVIOLCON                               DInfItem = 72  // Maximal primal bound violation for xc in the integer solution. Updated by the function updatesolutioninfo.
	DINF_SOL_ITG_PVIOLCONES                             DInfItem = 73  // Maximal primal violation for primal conic constraints in the integer solution. Updated by the function updatesolutioninfo.
	DINF_SOL_ITG_PVIOLDJC                               DInfItem = 74  // Maximal primal violation for disjunctive constraints in the integer solution. Updated by the function updatesolutioninfo.
	DINF_SOL_ITG_PVIOLITG                               DInfItem = 75  // Maximal violation for the integer constraints in the integer solution. Updated by the function updatesolutioninfo.
	DINF_SOL_ITG_PVIOLVAR                               DInfItem = 76  // Maximal primal bound violation for xx in the integer solution. Updated by the function updatesolutioninfo.
	DINF_SOL_ITR_DUAL_OBJ                               DInfItem = 77  // Dual objective value of the interior-point solution. Updated by the function updatesolutioninfo.
	DINF_SOL_ITR_DVIOLACC                               DInfItem = 78  // Maximal dual violation for affine conic constraints in the interior-point solution. Updated by the function updatesolutioninfo.
	DINF_SOL_ITR_DVIOLBARVAR                            DInfItem = 79  // Maximal dual bound violation for barx in the interior-point solution. Updated by the function updatesolutioninfo.
	DINF_SOL_ITR_DVIOLCON                               DInfItem = 80  // Maximal dual bound violation for xc in the interior-point solution. Updated by the function updatesolutioninfo.
	DINF_SOL_ITR_DVIOLCONES                             DInfItem = 81  // Maximal dual violation for conic constraints in the interior-point solution. Updated by the function updatesolutioninfo.
	DINF_SOL_ITR_DVIOLVAR                               DInfItem = 82  // Maximal dual bound violation for xx in the interior-point solution. Updated by the function updatesolutioninfo.
	DINF_SOL_ITR_NRM_BARS                               DInfItem = 83  // Infinity norm of bars in the interior-point solution.
	DINF_SOL_ITR_NRM_BARX                               DInfItem = 84  // Infinity norm of barx in the interior-point solution.
	DINF_SOL_ITR_NRM_SLC                                DInfItem = 85  // Infinity norm of slc in the interior-point solution.
	DINF_SOL_ITR_NRM_SLX                                DInfItem = 86  // Infinity norm of slx in the interior-point solution.
	DINF_SOL_ITR_NRM_SNX                                DInfItem = 87  // Infinity norm of snx in the interior-point solution.
	DINF_SOL_ITR_NRM_SUC                                DInfItem = 88  // Infinity norm of suc in the interior-point solution.
	DINF_SOL_ITR_NRM_SUX                                DInfItem = 89  // Infinity norm of sux in the interior-point solution.
	DINF_SOL_ITR_NRM_XC                                 DInfItem = 90  // Infinity norm of xc in the interior-point solution.
	DINF_SOL_ITR_NRM_XX                                 DInfItem = 91  // Infinity norm of xx in the interior-point solution.
	DINF_SOL_ITR_NRM_Y                                  DInfItem = 92  // Infinity norm of Y in the interior-point solution.
	DINF_SOL_ITR_PRIMAL_OBJ                             DInfItem = 93  // Primal objective value of the interior-point solution.
	DINF_SOL_ITR_PVIOLACC                               DInfItem = 94  // Maximal primal violation for affine conic constraints in the interior-point solution. Updated by the function updatesolutioninfo.
	DINF_SOL_ITR_PVIOLBARVAR                            DInfItem = 95  // Maximal primal bound violation for barx in the interior-point solution. Updated by the function updatesolutioninfo.
	DINF_SOL_ITR_PVIOLCON                               DInfItem = 96  // Maximal primal bound violation for xc in the interior-point solution. Updated by the function updatesolutioninfo.
	DINF_SOL_ITR_PVIOLCONES                             DInfItem = 97  // Maximal primal violation for conic constraints in the interior-point solution. Updated by the function updatesolutioninfo.
	DINF_SOL_ITR_PVIOLVAR                               DInfItem = 98  // Maximal primal bound violation for xx in the interior-point solution. Updated by the function updatesolutioninfo.
	DINF_TO_CONIC_TIME                                  DInfItem = 99  // Time spent in the last to conic reformulation.
	DINF_WRITE_DATA_TIME                                DInfItem = 100 // Time spent writing the data file.
)

// Feature is MSKfeature_enum
//
// License feature
type Feature uint32

const (
	FEATURE_PTS  Feature = 0 // Base system.
	FEATURE_PTON Feature = 1 // Conic extension.
)

// DParam is MSKdparam_enum
//
// Double parameters
type DParam uint32

const (
	DPAR_ANA_SOL_INFEAS_TOL                      DParam = 0  // If a constraint violates its bound with an amount larger than this value, the constraint name, index and violation will be printed by the solution analyzer.
	DPAR_BASIS_REL_TOL_S                         DParam = 1  // Maximum relative dual bound violation allowed in an optimal basic solution.
	DPAR_BASIS_TOL_S                             DParam = 2  // Maximum absolute dual bound violation in an optimal basic solution.
	DPAR_BASIS_TOL_X                             DParam = 3  // Maximum absolute primal bound violation allowed in an optimal basic solution.
	DPAR_CHECK_CONVEXITY_REL_TOL                 DParam = 4  // Convexity check tolerance.
	DPAR_DATA_SYM_MAT_TOL                        DParam = 5  // Zero tolerance threshold for symmetric matrices.
	DPAR_DATA_SYM_MAT_TOL_HUGE                   DParam = 6  // Data tolerance threshold.
	DPAR_DATA_SYM_MAT_TOL_LARGE                  DParam = 7  // Data tolerance threshold.
	DPAR_DATA_TOL_AIJ_HUGE                       DParam = 8  // Data tolerance threshold.
	DPAR_DATA_TOL_AIJ_LARGE                      DParam = 9  // Data tolerance threshold.
	DPAR_DATA_TOL_BOUND_INF                      DParam = 10 // Data tolerance threshold.
	DPAR_DATA_TOL_BOUND_WRN                      DParam = 11 // Data tolerance threshold.
	DPAR_DATA_TOL_C_HUGE                         DParam = 12 // Data tolerance threshold.
	DPAR_DATA_TOL_CJ_LARGE                       DParam = 13 // Data tolerance threshold.
	DPAR_DATA_TOL_QIJ                            DParam = 14 // Data tolerance threshold.
	DPAR_DATA_TOL_X                              DParam = 15 // Data tolerance threshold.
	DPAR_INTPNT_CO_TOL_DFEAS                     DParam = 16 // Dual feasibility tolerance used by the interior-point optimizer for conic problems.
	DPAR_INTPNT_CO_TOL_INFEAS                    DParam = 17 // Infeasibility tolerance used by the interior-point optimizer for conic problems.
	DPAR_INTPNT_CO_TOL_MU_RED                    DParam = 18 // Relative complementarity gap tolerance used by the interior-point optimizer for conic problems.
	DPAR_INTPNT_CO_TOL_NEAR_REL                  DParam = 19 // Optimality tolerance used by the interior-point optimizer for conic problems.
	DPAR_INTPNT_CO_TOL_PFEAS                     DParam = 20 // Primal feasibility tolerance used by the interior-point optimizer for conic problems.
	DPAR_INTPNT_CO_TOL_REL_GAP                   DParam = 21 // Relative gap termination tolerance used by the interior-point optimizer for conic problems.
	DPAR_INTPNT_QO_TOL_DFEAS                     DParam = 22 // Dual feasibility tolerance used by the interior-point optimizer for quadratic problems.
	DPAR_INTPNT_QO_TOL_INFEAS                    DParam = 23 // Infeasibility tolerance used by the interior-point optimizer for quadratic problems.
	DPAR_INTPNT_QO_TOL_MU_RED                    DParam = 24 // Relative complementarity gap tolerance used by the interior-point optimizer for quadratic problems.
	DPAR_INTPNT_QO_TOL_NEAR_REL                  DParam = 25 // Optimality tolerance used by the interior-point optimizer for quadratic problems.
	DPAR_INTPNT_QO_TOL_PFEAS                     DParam = 26 // Primal feasibility tolerance used by the interior-point optimizer for quadratic problems.
	DPAR_INTPNT_QO_TOL_REL_GAP                   DParam = 27 // Relative gap termination tolerance used by the interior-point optimizer for quadratic problems.
	DPAR_INTPNT_TOL_DFEAS                        DParam = 28 // Dual feasibility tolerance used by the interior-point optimizer for linear problems.
	DPAR_INTPNT_TOL_DSAFE                        DParam = 29 // Controls the interior-point dual starting point.
	DPAR_INTPNT_TOL_INFEAS                       DParam = 30 // Infeasibility tolerance used by the interior-point optimizer for linear problems.
	DPAR_INTPNT_TOL_MU_RED                       DParam = 31 // Relative complementarity gap tolerance used by the interior-point optimizer for linear problems.
	DPAR_INTPNT_TOL_PATH                         DParam = 32 // Interior-point centering aggressiveness.
	DPAR_INTPNT_TOL_PFEAS                        DParam = 33 // Primal feasibility tolerance used by the interior-point optimizer for linear problems.
	DPAR_INTPNT_TOL_PSAFE                        DParam = 34 // Controls the interior-point primal starting point.
	DPAR_INTPNT_TOL_REL_GAP                      DParam = 35 // Relative gap termination tolerance used by the interior-point optimizer for linear problems.
	DPAR_INTPNT_TOL_REL_STEP                     DParam = 36 // Relative step size to the boundary for linear and quadratic optimization problems.
	DPAR_INTPNT_TOL_STEP_SIZE                    DParam = 37 // Minimal step size tolerance for the interior-point optimizer.
	DPAR_LOWER_OBJ_CUT                           DParam = 38 // Objective bound.
	DPAR_LOWER_OBJ_CUT_FINITE_TRH                DParam = 39 // Objective bound.
	DPAR_MIO_DJC_MAX_BIGM                        DParam = 40 // Maximum allowed big-M value when reformulating disjunctive constraints to linear constraints.
	DPAR_MIO_MAX_TIME                            DParam = 41 // Time limit for the mixed-integer optimizer.
	DPAR_MIO_REL_GAP_CONST                       DParam = 42 // This value is used to compute the relative gap for the solution to an integer optimization problem.
	DPAR_MIO_TOL_ABS_GAP                         DParam = 43 // Absolute optimality tolerance employed by the mixed-integer optimizer.
	DPAR_MIO_TOL_ABS_RELAX_INT                   DParam = 44 // Integer feasibility tolerance.
	DPAR_MIO_TOL_FEAS                            DParam = 45 // Feasibility tolerance for mixed integer solver.
	DPAR_MIO_TOL_REL_DUAL_BOUND_IMPROVEMENT      DParam = 46 // Controls cut generation for mixed-integer optimizer.
	DPAR_MIO_TOL_REL_GAP                         DParam = 47 // Relative optimality tolerance employed by the mixed-integer optimizer.
	DPAR_OPTIMIZER_MAX_TIME                      DParam = 48 // Solver time limit.
	DPAR_PRESOLVE_TOL_ABS_LINDEP                 DParam = 49 // Absolute tolerance employed by the linear dependency checker.
	DPAR_PRESOLVE_TOL_AIJ                        DParam = 50 // Absolute zero tolerance employed for constraint coefficients in the presolve.
	DPAR_PRESOLVE_TOL_PRIMAL_INFEAS_PERTURBATION DParam = 51 // The presolve is allowed to perturbe a bound on a constraint or variable by this amount if it removes an infeasibility.
	DPAR_PRESOLVE_TOL_REL_LINDEP                 DParam = 52 // Relative tolerance employed by the linear dependency checker.
	DPAR_PRESOLVE_TOL_S                          DParam = 53 // Absolute zero tolerance employed for slack variables in the presolve.
	DPAR_PRESOLVE_TOL_X                          DParam = 54 // Absolute zero tolerance employed for variables in the presolve.
	DPAR_QCQO_REFORMULATE_REL_DROP_TOL           DParam = 55 // This parameter determines when columns are dropped in incomplete Cholesky factorization during reformulation of quadratic problems.
	DPAR_SEMIDEFINITE_TOL_APPROX                 DParam = 56 // Tolerance to define a matrix to be positive semidefinite.
	DPAR_SIM_LU_TOL_REL_PIV                      DParam = 57 // Relative pivot tolerance employed when computing the LU factorization of the basis matrix.
	DPAR_SIMPLEX_ABS_TOL_PIV                     DParam = 58 // Absolute pivot tolerance employed by the simplex optimizers.
	DPAR_UPPER_OBJ_CUT                           DParam = 59 // Objective bound.
	DPAR_UPPER_OBJ_CUT_FINITE_TRH                DParam = 60 // Objective bound.
)

// LIInfItem is MSKliinfitem_enum
//
// Long integer information items.
type LIInfItem uint32

const (
	LIINF_ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_NUM_COLUMNS LIInfItem = 0  // Number of columns in the scalarized constraint matrix.
	LIINF_ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_NUM_NZ      LIInfItem = 1  // Number of non-zero entries in the scalarized constraint matrix.
	LIINF_ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_NUM_ROWS    LIInfItem = 2  // Number of rows in the scalarized constraint matrix.
	LIINF_BI_CLEAN_DUAL_DEG_ITER                           LIInfItem = 3  // Number of dual degenerate clean iterations performed in the basis identification.
	LIINF_BI_CLEAN_DUAL_ITER                               LIInfItem = 4  // Number of dual clean iterations performed in the basis identification.
	LIINF_BI_CLEAN_PRIMAL_DEG_ITER                         LIInfItem = 5  // Number of primal degenerate clean iterations performed in the basis identification.
	LIINF_BI_CLEAN_PRIMAL_ITER                             LIInfItem = 6  // Number of primal clean iterations performed in the basis identification.
	LIINF_BI_DUAL_ITER                                     LIInfItem = 7  // Number of dual pivots performed in the basis identification.
	LIINF_BI_PRIMAL_ITER                                   LIInfItem = 8  // Number of primal pivots performed in the basis identification.
	LIINF_INTPNT_FACTOR_NUM_NZ                             LIInfItem = 9  // Number of non-zeros in factorization.
	LIINF_MIO_ANZ                                          LIInfItem = 10 // Number of non-zero entries in the constraint matrix of the problem to be solved by the mixed-integer optimizer.
	LIINF_MIO_INTPNT_ITER                                  LIInfItem = 11 // Number of interior-point iterations performed by the mixed-integer optimizer.
	LIINF_MIO_NUM_DUAL_ILLPOSED_CER                        LIInfItem = 12 // Number of dual illposed certificates encountered by the mixed-integer optimizer.
	LIINF_MIO_NUM_PRIM_ILLPOSED_CER                        LIInfItem = 13 // Number of primal illposed certificates encountered by the mixed-integer optimizer.
	LIINF_MIO_PRESOLVED_ANZ                                LIInfItem = 14 // Number of non-zero entries in the constraint matrix of the problem after the mixed-integer optimizer's presolve.
	LIINF_MIO_SIMPLEX_ITER                                 LIInfItem = 15 // Number of simplex iterations performed by the mixed-integer optimizer.
	LIINF_RD_NUMACC                                        LIInfItem = 16 // Number of affince conic constraints.
	LIINF_RD_NUMANZ                                        LIInfItem = 17 // Number of non-zeros in A that is read.
	LIINF_RD_NUMDJC                                        LIInfItem = 18 // Number of disjuncive constraints.
	LIINF_RD_NUMQNZ                                        LIInfItem = 19 // Number of Q non-zeros.
	LIINF_SIMPLEX_ITER                                     LIInfItem = 20 // Number of iterations performed by the simplex optimizer.
)

// IInfItem is MSKiinfitem_enum
//
// Integer information items.
type IInfItem uint32

const (
	IINF_ANA_PRO_NUM_CON                   IInfItem = 0   // Number of constraints in the problem.
	IINF_ANA_PRO_NUM_CON_EQ                IInfItem = 1   // Number of equality constraints.
	IINF_ANA_PRO_NUM_CON_FR                IInfItem = 2   // Number of unbounded constraints.
	IINF_ANA_PRO_NUM_CON_LO                IInfItem = 3   // Number of constraints with a lower bound and an infinite upper bound.
	IINF_ANA_PRO_NUM_CON_RA                IInfItem = 4   // Number of constraints with finite lower and upper bounds.
	IINF_ANA_PRO_NUM_CON_UP                IInfItem = 5   // Number of constraints with an upper bound and an infinite lower bound.
	IINF_ANA_PRO_NUM_VAR                   IInfItem = 6   // Number of variables in the problem.
	IINF_ANA_PRO_NUM_VAR_BIN               IInfItem = 7   // Number of binary variables.
	IINF_ANA_PRO_NUM_VAR_CONT              IInfItem = 8   // Number of continuous variables.
	IINF_ANA_PRO_NUM_VAR_EQ                IInfItem = 9   // Number of fixed variables.
	IINF_ANA_PRO_NUM_VAR_FR                IInfItem = 10  // Number of unbounded constraints.
	IINF_ANA_PRO_NUM_VAR_INT               IInfItem = 11  // Number of general integer variables.
	IINF_ANA_PRO_NUM_VAR_LO                IInfItem = 12  // Number of variables with a lower bound and an infinite upper bound.
	IINF_ANA_PRO_NUM_VAR_RA                IInfItem = 13  // Number of variables with finite lower and upper bounds.
	IINF_ANA_PRO_NUM_VAR_UP                IInfItem = 14  // Number of variables with an upper bound and an infinite lower bound.
	IINF_INTPNT_FACTOR_DIM_DENSE           IInfItem = 15  // Dimension of the dense sub system in factorization.
	IINF_INTPNT_ITER                       IInfItem = 16  // Number of interior-point iterations since invoking the interior-point optimizer.
	IINF_INTPNT_NUM_THREADS                IInfItem = 17  // Number of threads that the interior-point optimizer is using.
	IINF_INTPNT_SOLVE_DUAL                 IInfItem = 18  // Non-zero if the interior-point optimizer is solving the dual problem.
	IINF_MIO_ABSGAP_SATISFIED              IInfItem = 19  // Non-zero if absolute gap is within tolerances.
	IINF_MIO_CLIQUE_TABLE_SIZE             IInfItem = 20  // Size of the clique table.
	IINF_MIO_CONSTRUCT_SOLUTION            IInfItem = 21  // Informs if MOSEK successfully constructed an initial integer feasible solution.
	IINF_MIO_INITIAL_FEASIBLE_SOLUTION     IInfItem = 22  // Informs if MOSEK found the solution provided by the user to be feasible
	IINF_MIO_NODE_DEPTH                    IInfItem = 23  // Depth of the last node solved.
	IINF_MIO_NUM_ACTIVE_NODES              IInfItem = 24  // Number of active branch and bound nodes.
	IINF_MIO_NUM_BRANCH                    IInfItem = 25  // Number of branches performed during the optimization.
	IINF_MIO_NUM_CLIQUE_CUTS               IInfItem = 26  // Number of clique cuts.
	IINF_MIO_NUM_CMIR_CUTS                 IInfItem = 27  // Number of Complemented Mixed Integer Rounding (CMIR) cuts.
	IINF_MIO_NUM_GOMORY_CUTS               IInfItem = 28  // Number of Gomory cuts.
	IINF_MIO_NUM_IMPLIED_BOUND_CUTS        IInfItem = 29  // Number of implied bound cuts.
	IINF_MIO_NUM_INT_SOLUTIONS             IInfItem = 30  // Number of integer feasible solutions that have been found.
	IINF_MIO_NUM_KNAPSACK_COVER_CUTS       IInfItem = 31  // Number of clique cuts.
	IINF_MIO_NUM_LIPRO_CUTS                IInfItem = 32  // Number of lift-and-project cuts.
	IINF_MIO_NUM_RELAX                     IInfItem = 33  // Number of relaxations solved during the optimization.
	IINF_MIO_NUM_REPEATED_PRESOLVE         IInfItem = 34  // Number of times presolve was repeated at root.
	IINF_MIO_NUMBIN                        IInfItem = 35  // Number of binary variables in the problem to be solved by the mixed-integer optimizer.
	IINF_MIO_NUMBINCONEVAR                 IInfItem = 36  // Number of binary cone variables in the problem to be solved by the mixed-integer optimizer.
	IINF_MIO_NUMCON                        IInfItem = 37  // Number of constraints in the problem to be solved by the mixed-integer optimizer.
	IINF_MIO_NUMCONE                       IInfItem = 38  // Number of cones in the problem to be solved by the mixed-integer optimizer.
	IINF_MIO_NUMCONEVAR                    IInfItem = 39  // Number of cone variables in the problem to be solved by the mixed-integer optimizer.
	IINF_MIO_NUMCONT                       IInfItem = 40  // Number of continuous variables in the problem to be solved by the mixed-integer optimizer.
	IINF_MIO_NUMCONTCONEVAR                IInfItem = 41  // Number of continuous cone variables in the problem to be solved by the mixed-integer optimizer.
	IINF_MIO_NUMDEXPCONES                  IInfItem = 42  // Number of dual exponential cones in the problem to be solved by the mixed-integer optimizer.
	IINF_MIO_NUMDJC                        IInfItem = 43  // Number of disjunctive constraints in the problem to be solved by the mixed-integer optimizer.
	IINF_MIO_NUMDPOWCONES                  IInfItem = 44  // Number of dual power cones in the problem to be solved by the mixed-integer optimizer.
	IINF_MIO_NUMINT                        IInfItem = 45  // Number of integer variables in the problem to be solved by the mixed-integer optimizer.
	IINF_MIO_NUMINTCONEVAR                 IInfItem = 46  // Number of integer cone variables in the problem to be solved by the mixed-integer optimizer.
	IINF_MIO_NUMPEXPCONES                  IInfItem = 47  // Number of primal exponential cones in the problem to be solved by the mixed-integer optimizer.
	IINF_MIO_NUMPPOWCONES                  IInfItem = 48  // Number of primal power cones in the problem to be solved by the mixed-integer optimizer.
	IINF_MIO_NUMQCONES                     IInfItem = 49  // Number of quadratic cones in the problem to be solved by the mixed-integer optimizer.
	IINF_MIO_NUMRQCONES                    IInfItem = 50  // Number of rotated quadratic cones in the problem to be solved by the mixed-integer optimizer.
	IINF_MIO_NUMVAR                        IInfItem = 51  // Number of variables in the problem to be solved by the mixed-integer optimizer.
	IINF_MIO_OBJ_BOUND_DEFINED             IInfItem = 52  // Non-zero if a valid objective bound has been found, otherwise zero.
	IINF_MIO_PRESOLVED_NUMBIN              IInfItem = 53  // Number of binary variables in the problem after the mixed-integer optimizer's presolve.
	IINF_MIO_PRESOLVED_NUMBINCONEVAR       IInfItem = 54  // Number of binary cone variables in the problem after the mixed-integer optimizer's presolve.
	IINF_MIO_PRESOLVED_NUMCON              IInfItem = 55  // Number of constraints in the problem after the mixed-integer optimizer's presolve.
	IINF_MIO_PRESOLVED_NUMCONE             IInfItem = 56  // Number of cones in the problem after the mixed-integer optimizer's presolve.
	IINF_MIO_PRESOLVED_NUMCONEVAR          IInfItem = 57  // Number of cone variables in the problem after the mixed-integer optimizer's presolve.
	IINF_MIO_PRESOLVED_NUMCONT             IInfItem = 58  // Number of continuous variables in the problem after the mixed-integer optimizer's presolve.
	IINF_MIO_PRESOLVED_NUMCONTCONEVAR      IInfItem = 59  // Number of continuous cone variables in the problem after the mixed-integer optimizer's presolve.
	IINF_MIO_PRESOLVED_NUMDEXPCONES        IInfItem = 60  // Number of dual exponential cones in the problem after the mixed-integer optimizer's presolve.
	IINF_MIO_PRESOLVED_NUMDJC              IInfItem = 61  // Number of disjunctive constraints in the problem after the mixed-integer optimizer's presolve.
	IINF_MIO_PRESOLVED_NUMDPOWCONES        IInfItem = 62  // Number of dual power cones in the problem after the mixed-integer optimizer's presolve.
	IINF_MIO_PRESOLVED_NUMINT              IInfItem = 63  // Number of integer variables in the problem after the mixed-integer optimizer's presolve.
	IINF_MIO_PRESOLVED_NUMINTCONEVAR       IInfItem = 64  // Number of integer cone variables in the problem after the mixed-integer optimizer's presolve.
	IINF_MIO_PRESOLVED_NUMPEXPCONES        IInfItem = 65  // Number of primal exponential cones in the problem after the mixed-integer optimizer's presolve.
	IINF_MIO_PRESOLVED_NUMPPOWCONES        IInfItem = 66  // Number of primal power cones in the problem after the mixed-integer optimizer's presolve.
	IINF_MIO_PRESOLVED_NUMQCONES           IInfItem = 67  // Number of quadratic cones in the problem after the mixed-integer optimizer's presolve.
	IINF_MIO_PRESOLVED_NUMRQCONES          IInfItem = 68  // Number of rotated quadratic cones in the problem after the mixed-integer optimizer's presolve.
	IINF_MIO_PRESOLVED_NUMVAR              IInfItem = 69  // Number of variables in the problem after the mixed-integer optimizer's presolve.
	IINF_MIO_RELGAP_SATISFIED              IInfItem = 70  // Non-zero if relative gap is within tolerances.
	IINF_MIO_TOTAL_NUM_CUTS                IInfItem = 71  // Total number of cuts generated by the mixed-integer optimizer.
	IINF_MIO_USER_OBJ_CUT                  IInfItem = 72  // If it is non-zero, then the objective cut is used.
	IINF_OPT_NUMCON                        IInfItem = 73  // Number of constraints in the problem solved when the optimizer is called.
	IINF_OPT_NUMVAR                        IInfItem = 74  // Number of variables in the problem solved when the optimizer is called
	IINF_OPTIMIZE_RESPONSE                 IInfItem = 75  // The response code returned by optimize.
	IINF_PRESOLVE_NUM_PRIMAL_PERTURBATIONS IInfItem = 76  // Number perturbations to thhe bounds of the primal problem.
	IINF_PURIFY_DUAL_SUCCESS               IInfItem = 77  // Is nonzero if the dual solution is purified.
	IINF_PURIFY_PRIMAL_SUCCESS             IInfItem = 78  // Is nonzero if the primal solution is purified.
	IINF_RD_NUMBARVAR                      IInfItem = 79  // Number of symmetric variables read.
	IINF_RD_NUMCON                         IInfItem = 80  // Number of constraints read.
	IINF_RD_NUMCONE                        IInfItem = 81  // Number of conic constraints read.
	IINF_RD_NUMINTVAR                      IInfItem = 82  // Number of integer-constrained variables read.
	IINF_RD_NUMQ                           IInfItem = 83  // Number of nonempty Q matrices read.
	IINF_RD_NUMVAR                         IInfItem = 84  // Number of variables read.
	IINF_RD_PROTYPE                        IInfItem = 85  // Problem type.
	IINF_SIM_DUAL_DEG_ITER                 IInfItem = 86  // The number of dual degenerate iterations.
	IINF_SIM_DUAL_HOTSTART                 IInfItem = 87  // If 1 then the dual simplex algorithm is solving from an advanced basis.
	IINF_SIM_DUAL_HOTSTART_LU              IInfItem = 88  // If 1 then a valid basis factorization of full rank was located and used by the dual simplex algorithm.
	IINF_SIM_DUAL_INF_ITER                 IInfItem = 89  // The number of iterations taken with dual infeasibility.
	IINF_SIM_DUAL_ITER                     IInfItem = 90  // Number of dual simplex iterations during the last optimization.
	IINF_SIM_NUMCON                        IInfItem = 91  // Number of constraints in the problem solved by the simplex optimizer.
	IINF_SIM_NUMVAR                        IInfItem = 92  // Number of variables in the problem solved by the simplex optimizer.
	IINF_SIM_PRIMAL_DEG_ITER               IInfItem = 93  // The number of primal degenerate iterations.
	IINF_SIM_PRIMAL_HOTSTART               IInfItem = 94  // If 1 then the primal simplex algorithm is solving from an advanced basis.
	IINF_SIM_PRIMAL_HOTSTART_LU            IInfItem = 95  // If 1 then a valid basis factorization of full rank was located and used by the primal simplex algorithm.
	IINF_SIM_PRIMAL_INF_ITER               IInfItem = 96  // The number of iterations taken with primal infeasibility.
	IINF_SIM_PRIMAL_ITER                   IInfItem = 97  // Number of primal simplex iterations during the last optimization.
	IINF_SIM_SOLVE_DUAL                    IInfItem = 98  // Is non-zero if dual problem is solved.
	IINF_SOL_BAS_PROSTA                    IInfItem = 99  // Problem status of the basic solution. Updated after each optimization.
	IINF_SOL_BAS_SOLSTA                    IInfItem = 100 // Solution status of the basic solution. Updated after each optimization.
	IINF_SOL_ITG_PROSTA                    IInfItem = 101 // Problem status of the integer solution. Updated after each optimization.
	IINF_SOL_ITG_SOLSTA                    IInfItem = 102 // Solution status of the integer solution. Updated after each optimization.
	IINF_SOL_ITR_PROSTA                    IInfItem = 103 // Problem status of the interior-point solution. Updated after each optimization.
	IINF_SOL_ITR_SOLSTA                    IInfItem = 104 // Solution status of the interior-point solution. Updated after each optimization.
	IINF_STO_NUM_A_REALLOC                 IInfItem = 105 // Number of times the storage for storing the linear coefficient matrix has been changed.
)

// InfType is MSKinftype_enum
//
// Information item types
type InfType uint32

const (
	INF_DOU_TYPE  InfType = 0 // Is a double information type.
	INF_INT_TYPE  InfType = 1 // Is an integer.
	INF_LINT_TYPE InfType = 2 // Is a long integer.
)

// IoMode is MSKiomode_enum
//
// Input/output modes
type IoMode uint32

const (
	IOMODE_READ      IoMode = 0 // The file is read-only.
	IOMODE_WRITE     IoMode = 1 // The file is write-only. If the file exists then it is truncated when it is opened. Otherwise it is created when it is opened.
	IOMODE_READWRITE IoMode = 2 // The file is to read and write.
)

// IParam is MSKiparam_enum
//
// tells what paramete the integer parameter is set for
// in MSK_putintparam or [Task.PutIntParam].
type IParam uint32

const (
	IPAR_ANA_SOL_BASIS                      IParam = 0   // Controls whether the basis matrix is analyzed in solution analyzer.
	IPAR_ANA_SOL_PRINT_VIOLATED             IParam = 1   // Controls whether a list of violated constraints is printed.
	IPAR_AUTO_SORT_A_BEFORE_OPT             IParam = 2   // Controls whether the elements in each column of A are sorted before an optimization is performed.
	IPAR_AUTO_UPDATE_SOL_INFO               IParam = 3   // Controls whether the solution information items are automatically updated after an optimization is performed.
	IPAR_BASIS_SOLVE_USE_PLUS_ONE           IParam = 4   // Controls the sign of the columns in the basis matrix corresponding to slack variables.
	IPAR_BI_CLEAN_OPTIMIZER                 IParam = 5   // Controls which simplex optimizer is used in the clean-up phase.
	IPAR_BI_IGNORE_MAX_ITER                 IParam = 6   // Turns on basis identification in case the interior-point optimizer is terminated due to maximum number of iterations.
	IPAR_BI_IGNORE_NUM_ERROR                IParam = 7   // Turns on basis identification in case the interior-point optimizer is terminated due to a numerical problem.
	IPAR_BI_MAX_ITERATIONS                  IParam = 8   // Maximum number of iterations after basis identification.
	IPAR_CACHE_LICENSE                      IParam = 9   // Control license caching.
	IPAR_CHECK_CONVEXITY                    IParam = 10  // Specify the level of convexity check on quadratic problems.
	IPAR_COMPRESS_STATFILE                  IParam = 11  // Control compression of stat files.
	IPAR_INFEAS_GENERIC_NAMES               IParam = 12  // Controls the contents of the infeasibility report.
	IPAR_INFEAS_PREFER_PRIMAL               IParam = 13  // Controls which certificate is used if both primal- and dual- certificate of infeasibility is available.
	IPAR_INFEAS_REPORT_AUTO                 IParam = 14  // Turns the feasibility report on or off.
	IPAR_INFEAS_REPORT_LEVEL                IParam = 15  // Controls the contents of the infeasibility report.
	IPAR_INTPNT_BASIS                       IParam = 16  // Controls whether basis identification is performed.
	IPAR_INTPNT_DIFF_STEP                   IParam = 17  // Controls whether different step sizes are allowed in the primal and dual space.
	IPAR_INTPNT_HOTSTART                    IParam = 18  // Currently not in use.
	IPAR_INTPNT_MAX_ITERATIONS              IParam = 19  // Controls the maximum number of iterations allowed in the interior-point optimizer.
	IPAR_INTPNT_MAX_NUM_COR                 IParam = 20  // Maximum number of correction steps.
	IPAR_INTPNT_MAX_NUM_REFINEMENT_STEPS    IParam = 21  // Maximum number of steps to be used by the iterative search direction refinement.
	IPAR_INTPNT_OFF_COL_TRH                 IParam = 22  // Controls the aggressiveness of the offending column detection.
	IPAR_INTPNT_ORDER_GP_NUM_SEEDS          IParam = 23  // This parameter controls the number of random seeds tried.
	IPAR_INTPNT_ORDER_METHOD                IParam = 24  // Controls the ordering strategy.
	IPAR_INTPNT_PURIFY                      IParam = 25  // Currently not in use.
	IPAR_INTPNT_REGULARIZATION_USE          IParam = 26  // Controls whether regularization is allowed.
	IPAR_INTPNT_SCALING                     IParam = 27  // Controls how the problem is scaled before the interior-point optimizer is used.
	IPAR_INTPNT_SOLVE_FORM                  IParam = 28  // Controls whether the primal or the dual problem is solved.
	IPAR_INTPNT_STARTING_POINT              IParam = 29  // Starting point used by the interior-point optimizer.
	IPAR_LICENSE_DEBUG                      IParam = 30  // Controls the license manager client debugging behavior.
	IPAR_LICENSE_PAUSE_TIME                 IParam = 31  // Controls license manager client behavior.
	IPAR_LICENSE_SUPPRESS_EXPIRE_WRNS       IParam = 32  // Controls license manager client behavior.
	IPAR_LICENSE_TRH_EXPIRY_WRN             IParam = 33  // Controls when expiry warnings are issued.
	IPAR_LICENSE_WAIT                       IParam = 34  // Controls if MOSEK should queue for a license if none is available.
	IPAR_LOG                                IParam = 35  // Controls the amount of log information.
	IPAR_LOG_ANA_PRO                        IParam = 36  // Controls amount of output from the problem analyzer.
	IPAR_LOG_BI                             IParam = 37  // Controls the amount of output printed by the basis identification procedure. A higher level implies that more information is logged.
	IPAR_LOG_BI_FREQ                        IParam = 38  // Controls the logging frequency.
	IPAR_LOG_CHECK_CONVEXITY                IParam = 39  // Controls logging in convexity check on quadratic problems.
	IPAR_LOG_CUT_SECOND_OPT                 IParam = 40  // Controls the reduction in the log levels for the second and any subsequent optimizations.
	IPAR_LOG_EXPAND                         IParam = 41  // Controls the amount of logging when a data item such as the maximum number constrains is expanded.
	IPAR_LOG_FEAS_REPAIR                    IParam = 42  // Controls the amount of output printed when performing feasibility repair. A value higher than one means extensive logging.
	IPAR_LOG_FILE                           IParam = 43  // If turned on, then some log info is printed when a file is written or read.
	IPAR_LOG_INCLUDE_SUMMARY                IParam = 44  // Controls whether solution summary should be printed by the optimizer.
	IPAR_LOG_INFEAS_ANA                     IParam = 45  // Controls log level for the infeasibility analyzer.
	IPAR_LOG_INTPNT                         IParam = 46  // Controls the amount of log information from the interior-point optimizers.
	IPAR_LOG_LOCAL_INFO                     IParam = 47  // Control whether local identifying information is printed to the log.
	IPAR_LOG_MIO                            IParam = 48  // Controls the amount of log information from the mixed-integer optimizers.
	IPAR_LOG_MIO_FREQ                       IParam = 49  // The mixed-integer optimizer logging frequency.
	IPAR_LOG_ORDER                          IParam = 50  // If turned on, then factor lines are added to the log.
	IPAR_LOG_PRESOLVE                       IParam = 51  // Controls amount of output printed by the presolve procedure. A higher level implies that more information is logged.
	IPAR_LOG_RESPONSE                       IParam = 52  // Controls amount of output printed when response codes are reported. A higher level implies that more information is logged.
	IPAR_LOG_SENSITIVITY                    IParam = 53  // Control logging in sensitivity analyzer.
	IPAR_LOG_SENSITIVITY_OPT                IParam = 54  // Control logging in sensitivity analyzer.
	IPAR_LOG_SIM                            IParam = 55  // Controls the amount of log information from the simplex optimizers.
	IPAR_LOG_SIM_FREQ                       IParam = 56  // Controls simplex logging frequency.
	IPAR_LOG_SIM_MINOR                      IParam = 57  // Currently not in use.
	IPAR_LOG_STORAGE                        IParam = 58  // Controls the memory related log information.
	IPAR_MAX_NUM_WARNINGS                   IParam = 59  // Each warning is shown a limited number of times controlled by this parameter. A negative value is identical to infinite number of times.
	IPAR_MIO_BRANCH_DIR                     IParam = 60  // Controls whether the mixed-integer optimizer is branching up or down by default.
	IPAR_MIO_CONIC_OUTER_APPROXIMATION      IParam = 61  // Toggles outer approximation for conic problems.
	IPAR_MIO_CONSTRUCT_SOL                  IParam = 62  // Controls if an initial mixed integer solution should be constructed from the values of the integer variables.
	IPAR_MIO_CUT_CLIQUE                     IParam = 63  // Controls whether clique cuts should be generated.
	IPAR_MIO_CUT_CMIR                       IParam = 64  // Controls whether mixed integer rounding cuts should be generated.
	IPAR_MIO_CUT_GMI                        IParam = 65  // Controls whether GMI cuts should be generated.
	IPAR_MIO_CUT_IMPLIED_BOUND              IParam = 66  // Controls whether implied bound cuts should be generated.
	IPAR_MIO_CUT_KNAPSACK_COVER             IParam = 67  // Controls whether knapsack cover cuts should be generated.
	IPAR_MIO_CUT_LIPRO                      IParam = 68  // Controls whether lift-and-project cuts should be generated.
	IPAR_MIO_CUT_SELECTION_LEVEL            IParam = 69  // Controls how aggressively generated cuts are selected to be included in the relaxation.
	IPAR_MIO_DATA_PERMUTATION_METHOD        IParam = 70  // Controls what problem data permutation method is appplied to mixed-integer problems.
	IPAR_MIO_FEASPUMP_LEVEL                 IParam = 71  // Controls the way the Feasibility Pump heuristic is employed by the mixed-integer optimizer.
	IPAR_MIO_HEURISTIC_LEVEL                IParam = 72  // Controls the heuristic employed by the mixed-integer optimizer to locate an initial integer feasible solution.
	IPAR_MIO_MAX_NUM_BRANCHES               IParam = 73  // Maximum number of branches allowed during the branch and bound search.
	IPAR_MIO_MAX_NUM_RELAXS                 IParam = 74  // Maximum number of relaxations in branch and bound search.
	IPAR_MIO_MAX_NUM_ROOT_CUT_ROUNDS        IParam = 75  // Maximum number of cut separation rounds at the root node.
	IPAR_MIO_MAX_NUM_SOLUTIONS              IParam = 76  // Controls how many feasible solutions the mixed-integer optimizer investigates.
	IPAR_MIO_MEMORY_EMPHASIS_LEVEL          IParam = 77  // Controls how much emphasis is put on reducing memory usage.
	IPAR_MIO_MODE                           IParam = 78  // Turns on/off the mixed-integer mode.
	IPAR_MIO_NODE_OPTIMIZER                 IParam = 79  // Controls which optimizer is employed at the non-root nodes in the mixed-integer optimizer.
	IPAR_MIO_NODE_SELECTION                 IParam = 80  // Controls the node selection strategy employed by the mixed-integer optimizer.
	IPAR_MIO_NUMERICAL_EMPHASIS_LEVEL       IParam = 81  // Controls how much emphasis is put on reducing numerical problems
	IPAR_MIO_PERSPECTIVE_REFORMULATE        IParam = 82  // Enables or disables perspective reformulation in presolve.
	IPAR_MIO_PRESOLVE_AGGREGATOR_USE        IParam = 83  // Controls if the aggregator should be used.
	IPAR_MIO_PROBING_LEVEL                  IParam = 84  // Controls the amount of probing employed by the mixed-integer optimizer in presolve.
	IPAR_MIO_PROPAGATE_OBJECTIVE_CONSTRAINT IParam = 85  // Use objective domain propagation.
	IPAR_MIO_QCQO_REFORMULATION_METHOD      IParam = 86  // Controls what reformulation method is applied to mixed-integer quadratic problems.
	IPAR_MIO_RINS_MAX_NODES                 IParam = 87  // Maximum number of nodes in each call to RINS.
	IPAR_MIO_ROOT_OPTIMIZER                 IParam = 88  // Controls which optimizer is employed at the root node in the mixed-integer optimizer.
	IPAR_MIO_ROOT_REPEAT_PRESOLVE_LEVEL     IParam = 89  // Controls whether presolve can be repeated at root node.
	IPAR_MIO_SEED                           IParam = 90  // Sets the random seed used for randomization in the mixed integer optimizer.
	IPAR_MIO_SYMMETRY_LEVEL                 IParam = 91  // Controls the amount of symmetry detection and handling employed by the mixed-integer optimizer in presolve.
	IPAR_MIO_VB_DETECTION_LEVEL             IParam = 92  // Controls how much effort is put into detecting variable bounds.
	IPAR_MT_SPINCOUNT                       IParam = 93  // Set the number of iterations to spin before sleeping.
	IPAR_NG                                 IParam = 94  // Not in use
	IPAR_NUM_THREADS                        IParam = 95  // The number of threads employed by the optimizer.
	IPAR_OPF_WRITE_HEADER                   IParam = 96  // Write a text header with date and MOSEK version in an OPF file.
	IPAR_OPF_WRITE_HINTS                    IParam = 97  // Write a hint section with problem dimensions in the beginning of an OPF file.
	IPAR_OPF_WRITE_LINE_LENGTH              IParam = 98  // Aim to keep lines in OPF files not much longer than this.
	IPAR_OPF_WRITE_PARAMETERS               IParam = 99  // Write a parameter section in an OPF file.
	IPAR_OPF_WRITE_PROBLEM                  IParam = 100 // Write objective, constraints, bounds etc. to an OPF file.
	IPAR_OPF_WRITE_SOL_BAS                  IParam = 101 // Controls what is written to the OPF files.
	IPAR_OPF_WRITE_SOL_ITG                  IParam = 102 // Controls what is written to the OPF files.
	IPAR_OPF_WRITE_SOL_ITR                  IParam = 103 // Controls what is written to the OPF files.
	IPAR_OPF_WRITE_SOLUTIONS                IParam = 104 // Enable inclusion of solutions in the OPF files.
	IPAR_OPTIMIZER                          IParam = 105 // Controls which optimizer is used to optimize the task.
	IPAR_PARAM_READ_CASE_NAME               IParam = 106 // If turned on, then names in the parameter file are case sensitive.
	IPAR_PARAM_READ_IGN_ERROR               IParam = 107 // If turned on, then errors in parameter settings is ignored.
	IPAR_PRESOLVE_ELIMINATOR_MAX_FILL       IParam = 108 // Maximum amount of fill-in created in one pivot during the elimination phase.
	IPAR_PRESOLVE_ELIMINATOR_MAX_NUM_TRIES  IParam = 109 // Control the maximum number of times the eliminator is tried.
	IPAR_PRESOLVE_LEVEL                     IParam = 110 // Currently not used.
	IPAR_PRESOLVE_LINDEP_ABS_WORK_TRH       IParam = 111 // Controls linear dependency check in presolve.
	IPAR_PRESOLVE_LINDEP_REL_WORK_TRH       IParam = 112 // Controls linear dependency check in presolve.
	IPAR_PRESOLVE_LINDEP_USE                IParam = 113 // Controls whether the linear constraints are checked for linear dependencies.
	IPAR_PRESOLVE_MAX_NUM_PASS              IParam = 114 // Control the maximum number of times presolve passes over the problem.
	IPAR_PRESOLVE_MAX_NUM_REDUCTIONS        IParam = 115 // Controls the maximum number of reductions performed by the presolve.
	IPAR_PRESOLVE_USE                       IParam = 116 // Controls whether the presolve is applied to a problem before it is optimized.
	IPAR_PRIMAL_REPAIR_OPTIMIZER            IParam = 117 // Controls which optimizer that is used to find the optimal repair.
	IPAR_PTF_WRITE_PARAMETERS               IParam = 118 // Controls whether parameters section is written in PTF files.
	IPAR_PTF_WRITE_SOLUTIONS                IParam = 119 // Controls whether solution section is written in PTF files.
	IPAR_PTF_WRITE_TRANSFORM                IParam = 120 // Controls if simple transformation are done when writing PTF files.
	IPAR_READ_DEBUG                         IParam = 121 // Turns on additional debugging information when reading files.
	IPAR_READ_KEEP_FREE_CON                 IParam = 122 // Controls whether the free constraints are included in the problem.
	IPAR_READ_MPS_FORMAT                    IParam = 123 // Controls how strictly the MPS file reader interprets the MPS format.
	IPAR_READ_MPS_WIDTH                     IParam = 124 // Controls the maximal number of characters allowed in one line of the MPS file.
	IPAR_READ_TASK_IGNORE_PARAM             IParam = 125 // Controls what information is used from the task files.
	IPAR_REMOTE_USE_COMPRESSION             IParam = 126 // Use compression when sending data to an optimization server
	IPAR_REMOVE_UNUSED_SOLUTIONS            IParam = 127 // Removes unused solutions before the optimization is performed.
	IPAR_SENSITIVITY_ALL                    IParam = 128 // Controls sensitivity report behavior.
	IPAR_SENSITIVITY_OPTIMIZER              IParam = 129 // Controls which optimizer is used for optimal partition sensitivity analysis.
	IPAR_SENSITIVITY_TYPE                   IParam = 130 // Controls which type of sensitivity analysis is to be performed.
	IPAR_SIM_BASIS_FACTOR_USE               IParam = 131 // Controls whether an LU factorization of the basis is used in a hot-start.
	IPAR_SIM_DEGEN                          IParam = 132 // Controls how aggressively degeneration is handled.
	IPAR_SIM_DETECT_PWL                     IParam = 133 // Not in use.
	IPAR_SIM_DUAL_CRASH                     IParam = 134 // Controls whether crashing is performed in the dual simplex optimizer.
	IPAR_SIM_DUAL_PHASEONE_METHOD           IParam = 135 // An experimental feature.
	IPAR_SIM_DUAL_RESTRICT_SELECTION        IParam = 136 // Controls how aggressively restricted selection is used.
	IPAR_SIM_DUAL_SELECTION                 IParam = 137 // Controls the dual simplex strategy.
	IPAR_SIM_EXPLOIT_DUPVEC                 IParam = 138 // Controls if the simplex optimizers are allowed to exploit duplicated columns.
	IPAR_SIM_HOTSTART                       IParam = 139 // Controls the type of hot-start that the simplex optimizer perform.
	IPAR_SIM_HOTSTART_LU                    IParam = 140 // Determines if the simplex optimizer should exploit the initial factorization.
	IPAR_SIM_MAX_ITERATIONS                 IParam = 141 // Maximum number of iterations that can be used by a simplex optimizer.
	IPAR_SIM_MAX_NUM_SETBACKS               IParam = 142 // Controls how many set-backs that are allowed within a simplex optimizer.
	IPAR_SIM_NON_SINGULAR                   IParam = 143 // Controls if the simplex optimizer ensures a non-singular basis, if possible.
	IPAR_SIM_PRIMAL_CRASH                   IParam = 144 // Controls the simplex crash.
	IPAR_SIM_PRIMAL_PHASEONE_METHOD         IParam = 145 // An experimental feature.
	IPAR_SIM_PRIMAL_RESTRICT_SELECTION      IParam = 146 // Controls how aggressively restricted selection is used.
	IPAR_SIM_PRIMAL_SELECTION               IParam = 147 // Controls the primal simplex strategy.
	IPAR_SIM_REFACTOR_FREQ                  IParam = 148 // Controls the basis refactoring frequency.
	IPAR_SIM_REFORMULATION                  IParam = 149 // Controls if the simplex optimizers are allowed to reformulate the problem.
	IPAR_SIM_SAVE_LU                        IParam = 150 // Controls if the LU factorization stored should be replaced with the LU factorization corresponding to the initial basis.
	IPAR_SIM_SCALING                        IParam = 151 // Controls how much effort is used in scaling the problem before a simplex optimizer is used.
	IPAR_SIM_SCALING_METHOD                 IParam = 152 // Controls how the problem is scaled before a simplex optimizer is used.
	IPAR_SIM_SEED                           IParam = 153 // Sets the random seed used for randomization in the simplex optimizers.
	IPAR_SIM_SOLVE_FORM                     IParam = 154 // Controls whether the primal or the dual problem is solved by the primal-/dual-simplex optimizer.
	IPAR_SIM_STABILITY_PRIORITY             IParam = 155 // Controls how high priority the numerical stability should be given.
	IPAR_SIM_SWITCH_OPTIMIZER               IParam = 156 // Controls the simplex behavior.
	IPAR_SOL_FILTER_KEEP_BASIC              IParam = 157 // Control the contents of the solution files.
	IPAR_SOL_FILTER_KEEP_RANGED             IParam = 158 // Control the contents of the solution files.
	IPAR_SOL_READ_NAME_WIDTH                IParam = 159 // Controls the input solution file format.
	IPAR_SOL_READ_WIDTH                     IParam = 160 // Controls the input solution file format.
	IPAR_SOLUTION_CALLBACK                  IParam = 161 // Indicates whether solution callbacks will be performed during the optimization.
	IPAR_TIMING_LEVEL                       IParam = 162 // Controls the amount of timing performed inside MOSEK.
	IPAR_WRITE_BAS_CONSTRAINTS              IParam = 163 // Controls the basic solution file format.
	IPAR_WRITE_BAS_HEAD                     IParam = 164 // Controls the basic solution file format.
	IPAR_WRITE_BAS_VARIABLES                IParam = 165 // Controls the basic solution file format.
	IPAR_WRITE_COMPRESSION                  IParam = 166 // Controls output file compression.
	IPAR_WRITE_DATA_PARAM                   IParam = 167 // Controls output file data.
	IPAR_WRITE_FREE_CON                     IParam = 168 // Controls the output file data.
	IPAR_WRITE_GENERIC_NAMES                IParam = 169 // Controls the output file data.
	IPAR_WRITE_GENERIC_NAMES_IO             IParam = 170 // Index origin used in  generic names.
	IPAR_WRITE_IGNORE_INCOMPATIBLE_ITEMS    IParam = 171 // Controls if the writer ignores incompatible problem items when writing files.
	IPAR_WRITE_INT_CONSTRAINTS              IParam = 172 // Controls the integer solution file format.
	IPAR_WRITE_INT_HEAD                     IParam = 173 // Controls the integer solution file format.
	IPAR_WRITE_INT_VARIABLES                IParam = 174 // Controls the integer solution file format.
	IPAR_WRITE_JSON_INDENTATION             IParam = 175 // When set, the JSON task and solution files are written with indentation for better readability.
	IPAR_WRITE_LP_FULL_OBJ                  IParam = 176 // Write full linear objective
	IPAR_WRITE_LP_LINE_WIDTH                IParam = 177 // Controls the LP output file format.
	IPAR_WRITE_MPS_FORMAT                   IParam = 178 // Controls in which format the MPS is written.
	IPAR_WRITE_MPS_INT                      IParam = 179 // Controls the output file data.
	IPAR_WRITE_SOL_BARVARIABLES             IParam = 180 // Controls the solution file format.
	IPAR_WRITE_SOL_CONSTRAINTS              IParam = 181 // Controls the solution file format.
	IPAR_WRITE_SOL_HEAD                     IParam = 182 // Controls solution file format.
	IPAR_WRITE_SOL_IGNORE_INVALID_NAMES     IParam = 183 // Controls whether the user specified names are employed even if they are invalid names.
	IPAR_WRITE_SOL_VARIABLES                IParam = 184 // Controls the solution file format.
	IPAR_WRITE_TASK_INC_SOL                 IParam = 185 // Controls whether the solutions are stored in the task file too.
	IPAR_WRITE_XML_MODE                     IParam = 186 // Controls if linear coefficients should be written by row or column when writing in the XML file format.
)

// BranchDir is MSKbranchdir_enum
//
// Specifies the branching direction.
type BranchDir uint32

const (
	BRANCH_DIR_FREE       BranchDir = 0 // The mixed-integer optimizer decides which branch to choose.
	BRANCH_DIR_UP         BranchDir = 1 // The mixed-integer optimizer always chooses the up branch first.
	BRANCH_DIR_DOWN       BranchDir = 2 // The mixed-integer optimizer always chooses the down branch first.
	BRANCH_DIR_NEAR       BranchDir = 3 // Branch in direction nearest to selected fractional variable.
	BRANCH_DIR_FAR        BranchDir = 4 // Branch in direction farthest from selected fractional variable.
	BRANCH_DIR_ROOT_LP    BranchDir = 5 // Chose direction based on root lp value of selected variable.
	BRANCH_DIR_GUIDED     BranchDir = 6 // Branch in direction of current incumbent.
	BRANCH_DIR_PSEUDOCOST BranchDir = 7 // Branch based on the pseudocost of the variable.
)

// MiQcQoReformMethod is MSKmiqcqoreformmethod_enum
//
// Specifies the reformulation method for mixed-integer quadratic problems.
type MiQcQoReformMethod uint32

const (
	MIO_QCQO_REFORMULATION_METHOD_FREE             MiQcQoReformMethod = 0 // The mixed-integer optimizer decides which reformulation method to apply.
	MIO_QCQO_REFORMULATION_METHOD_NONE             MiQcQoReformMethod = 1 // No reformulation method is applied.
	MIO_QCQO_REFORMULATION_METHOD_LINEARIZATION    MiQcQoReformMethod = 2 // A reformulation via linearization is applied.
	MIO_QCQO_REFORMULATION_METHOD_EIGEN_VAL_METHOD MiQcQoReformMethod = 3 // The eigenvalue method is applied.
	MIO_QCQO_REFORMULATION_METHOD_DIAG_SDP         MiQcQoReformMethod = 4 // A perturbation of matrix diagonals via the solution of SDPs is applied.
	MIO_QCQO_REFORMULATION_METHOD_RELAX_SDP        MiQcQoReformMethod = 5 // A Reformulation based on the solution of an SDP-relaxation of the problem is applied.
)

// MioDataPermMethod is MSKmiodatapermmethod_enum
//
// Specifies the problem data permutation method for mixed-integer problems.
type MioDataPermMethod uint32

const (
	MIO_DATA_PERMUTATION_METHOD_NONE         MioDataPermMethod = 0 // No problem data permutation is applied.
	MIO_DATA_PERMUTATION_METHOD_CYCLIC_SHIFT MioDataPermMethod = 1 // A random cyclic shift is applied to permute the problem data.
	MIO_DATA_PERMUTATION_METHOD_RANDOM       MioDataPermMethod = 2 // A random permutation is applied to the problem data.
)

// MioContSolType is MSKmiocontsoltype_enum
//
// Continuous mixed-integer solution type
type MioContSolType uint32

const (
	MIO_CONT_SOL_NONE    MioContSolType = 0 // No interior-point or basic solution.
	MIO_CONT_SOL_ROOT    MioContSolType = 1 // Solutions to the root node problem.
	MIO_CONT_SOL_ITG     MioContSolType = 2 // A feasible primal solution.
	MIO_CONT_SOL_ITG_REL MioContSolType = 3 // A feasible primal solution or a root node solution if the problem is infeasible.
)

// MioMode is MSKmiomode_enum
//
// Integer restrictions
type MioMode uint32

const (
	MIO_MODE_IGNORED   MioMode = 0 // The integer constraints are ignored and the problem is solved as a continuous problem.
	MIO_MODE_SATISFIED MioMode = 1 // Integer restrictions should be satisfied.
)

// MioNodeSelType is MSKmionodeseltype_enum
//
// Mixed-integer node selection types
type MioNodeSelType uint32

const (
	MIO_NODE_SELECTION_FREE   MioNodeSelType = 0 // The optimizer decides the node selection strategy.
	MIO_NODE_SELECTION_FIRST  MioNodeSelType = 1 // The optimizer employs a depth first node selection strategy.
	MIO_NODE_SELECTION_BEST   MioNodeSelType = 2 // The optimizer employs a best bound node selection strategy.
	MIO_NODE_SELECTION_PSEUDO MioNodeSelType = 3 // The optimizer employs selects the node based on a pseudo cost estimate.
)

// MPSFormat is MSKmpsformat_enum
//
// MPS file format type
type MPSFormat uint32

const (
	MPS_FORMAT_STRICT  MPSFormat = 0 // It is assumed that the input file satisfies the MPS format strictly.
	MPS_FORMAT_RELAXED MPSFormat = 1 // It is assumed that the input file satisfies a slightly relaxed version of the MPS format.
	MPS_FORMAT_FREE    MPSFormat = 2 // It is assumed that the input file satisfies the free MPS format. This implies that spaces are not allowed in names. Otherwise the format is free.
	MPS_FORMAT_CPLEX   MPSFormat = 3 // The CPLEX compatible version of the MPS format is employed.
)

// ObjectiveSense is MSKobjsense_enum
//
// Objective sense types
type ObjectiveSense uint32

const (
	OBJECTIVE_SENSE_MINIMIZE ObjectiveSense = 0 // The problem should be minimized.
	OBJECTIVE_SENSE_MAXIMIZE ObjectiveSense = 1 // The problem should be maximized.
)

// OnOff is MSKonoffkey_enum
//
// This is alias of int32, because golang distinguishes
// the enum and integers.
type OnOff = int32

const (
	OFF OnOff = 0 // Switch the option off.
	ON  OnOff = 1 // Switch the option on.
)

// OptimizerType is MSKoptimizertype_enum
//
// can be set for the integer parameter [IPAR_OPTIMIZER]
type OptimizerType = int32

const (
	OPTIMIZER_CONIC          OptimizerType = 0 // The optimizer for problems having conic constraints.
	OPTIMIZER_DUAL_SIMPLEX   OptimizerType = 1 // The dual simplex optimizer is used.
	OPTIMIZER_FREE           OptimizerType = 2 // The optimizer is chosen automatically.
	OPTIMIZER_FREE_SIMPLEX   OptimizerType = 3 // One of the simplex optimizers is used.
	OPTIMIZER_INTPNT         OptimizerType = 4 // The interior-point optimizer is used.
	OPTIMIZER_MIXED_INT      OptimizerType = 5 // The mixed-integer optimizer.
	OPTIMIZER_PRIMAL_SIMPLEX OptimizerType = 6 // The primal simplex optimizer is used.
)

// OrderingType is MSKorderingtype_enum
//
// Ordering strategies
type OrderingType uint32

const (
	ORDER_METHOD_FREE           OrderingType = 0 // The ordering method is chosen automatically.
	ORDER_METHOD_APPMINLOC      OrderingType = 1 // Approximate minimum local fill-in ordering is employed.
	ORDER_METHOD_EXPERIMENTAL   OrderingType = 2 // This option should not be used.
	ORDER_METHOD_TRY_GRAPHPAR   OrderingType = 3 // Always try the graph partitioning based ordering.
	ORDER_METHOD_FORCE_GRAPHPAR OrderingType = 4 // Always use the graph partitioning based ordering even if it is worse than the approximate minimum local fill ordering.
	ORDER_METHOD_NONE           OrderingType = 5 // No ordering is used.
)

// PresolveMode is MSKpresolvemode_enum
//
// Presolve method.
type PresolveMode uint32

const (
	PRESOLVE_MODE_OFF  PresolveMode = 0 // The problem is not presolved before it is optimized.
	PRESOLVE_MODE_ON   PresolveMode = 1 // The problem is presolved before it is optimized.
	PRESOLVE_MODE_FREE PresolveMode = 2 // It is decided automatically whether to presolve before the problem is optimized.
)

// ParameterType is MSKparametertype_enum
//
// Parameter type
type ParameterType uint32

const (
	PAR_INVALID_TYPE ParameterType = 0 // Not a valid parameter.
	PAR_DOU_TYPE     ParameterType = 1 // Is a double parameter.
	PAR_INT_TYPE     ParameterType = 2 // Is an integer parameter.
	PAR_STR_TYPE     ParameterType = 3 // Is a string parameter.
)

// ProblemItem is MSKproblemitem_enum
//
// Problem data items
type ProblemItem uint32

const (
	PI_VAR  ProblemItem = 0 // Item is a variable.
	PI_CON  ProblemItem = 1 // Item is a constraint.
	PI_CONE ProblemItem = 2 // Item is a cone.
)

// ProblemType is MSKproblemtype_enum
//
// Problem types
type ProblemType uint32

const (
	PROBTYPE_LO    ProblemType = 0 // The problem is a linear optimization problem.
	PROBTYPE_QO    ProblemType = 1 // The problem is a quadratic optimization problem.
	PROBTYPE_QCQO  ProblemType = 2 // The problem is a quadratically constrained optimization problem.
	PROBTYPE_CONIC ProblemType = 3 // A conic optimization.
	PROBTYPE_MIXED ProblemType = 4 // General nonlinear constraints and conic constraints. This combination can not be solved by MOSEK.
)

// ProSta is MSKprosta_enum
//
// Problem status keys
type ProSta uint32

const (
	PRO_STA_UNKNOWN                  ProSta = 0 // Unknown problem status.
	PRO_STA_PRIM_AND_DUAL_FEAS       ProSta = 1 // The problem is primal and dual feasible.
	PRO_STA_PRIM_FEAS                ProSta = 2 // The problem is primal feasible.
	PRO_STA_DUAL_FEAS                ProSta = 3 // The problem is dual feasible.
	PRO_STA_PRIM_INFEAS              ProSta = 4 // The problem is primal infeasible.
	PRO_STA_DUAL_INFEAS              ProSta = 5 // The problem is dual infeasible.
	PRO_STA_PRIM_AND_DUAL_INFEAS     ProSta = 6 // The problem is primal and dual infeasible.
	PRO_STA_ILL_POSED                ProSta = 7 // The problem is ill-posed. For example, it may be primal and dual feasible but have a positive duality gap.
	PRO_STA_PRIM_INFEAS_OR_UNBOUNDED ProSta = 8 // The problem is either primal infeasible or unbounded. This may occur for mixed-integer problems.
)

// XmlWriterOutputType is MSKxmlwriteroutputtype_enum
//
// XML writer output mode
type XmlWriterOutputType uint32

const (
	WRITE_XML_MODE_ROW XmlWriterOutputType = 0 // Write in row order.
	WRITE_XML_MODE_COL XmlWriterOutputType = 1 // Write in column order.
)

// ResCodeType is MSKrescodetype_enum
//
// Response code type
type ResCodeType uint32

const (
	RESPONSE_OK  ResCodeType = 0 // The response code is OK.
	RESPONSE_WRN ResCodeType = 1 // The response code is a warning.
	RESPONSE_TRM ResCodeType = 2 // The response code is an optimizer termination status.
	RESPONSE_ERR ResCodeType = 3 // The response code is an error.
	RESPONSE_UNK ResCodeType = 4 // The response code does not belong to any class.
)

// ScalingType is MSKscalingtype_enum
//
// Scaling type
type ScalingType uint32

const (
	SCALING_FREE ScalingType = 0 // The optimizer chooses the scaling heuristic.
	SCALING_NONE ScalingType = 1 // No scaling is performed.
)

// ScalingMethod is MSKscalingmethod_enum
//
// Scaling method
type ScalingMethod uint32

const (
	SCALING_METHOD_POW2 ScalingMethod = 0 // Scales only with power of 2 leaving the mantissa untouched.
	SCALING_METHOD_FREE ScalingMethod = 1 // The optimizer chooses the scaling heuristic.
)

// SensitivityType is MSKsensitivitytype_enum
//
// Sensitivity types
type SensitivityType uint32

const (
	SENSITIVITY_TYPE_BASIS SensitivityType = 0 // Basis sensitivity analysis is performed.
)

// SimSelType is MSKsimseltype_enum
//
// Simplex selection strategy
type SimSelType uint32

const (
	SIM_SELECTION_FREE    SimSelType = 0 // The optimizer chooses the pricing strategy.
	SIM_SELECTION_FULL    SimSelType = 1 // The optimizer uses full pricing.
	SIM_SELECTION_ASE     SimSelType = 2 // The optimizer uses approximate steepest-edge pricing.
	SIM_SELECTION_DEVEX   SimSelType = 3 // The optimizer uses devex steepest-edge pricing.
	SIM_SELECTION_SE      SimSelType = 4 // The optimizer uses steepest-edge selection.
	SIM_SELECTION_PARTIAL SimSelType = 5 // The optimizer uses a partial selection approach.
)

// SolItem is MSKsolitem_enum
//
// Solution items
type SolItem uint32

const (
	SOL_ITEM_XC  SolItem = 0 // Solution for the constraints.
	SOL_ITEM_XX  SolItem = 1 // Variable solution.
	SOL_ITEM_Y   SolItem = 2 // Lagrange multipliers for equations.
	SOL_ITEM_SLC SolItem = 3 // Lagrange multipliers for lower bounds on the constraints.
	SOL_ITEM_SUC SolItem = 4 // Lagrange multipliers for upper bounds on the constraints.
	SOL_ITEM_SLX SolItem = 5 // Lagrange multipliers for lower bounds on the variables.
	SOL_ITEM_SUX SolItem = 6 // Lagrange multipliers for upper bounds on the variables.
	SOL_ITEM_SNX SolItem = 7 // Lagrange multipliers corresponding to the conic constraints on the variables.
)

// SolSta is MSKsolsta_enum
//
// Solution status keys
type SolSta uint32

const (
	SOL_STA_UNKNOWN            SolSta = 0 // Status of the solution is unknown.
	SOL_STA_OPTIMAL            SolSta = 1 // The solution is optimal.
	SOL_STA_PRIM_FEAS          SolSta = 2 // The solution is primal feasible.
	SOL_STA_DUAL_FEAS          SolSta = 3 // The solution is dual feasible.
	SOL_STA_PRIM_AND_DUAL_FEAS SolSta = 4 // The solution is both primal and dual feasible.
	SOL_STA_PRIM_INFEAS_CER    SolSta = 5 // The solution is a certificate of primal infeasibility.
	SOL_STA_DUAL_INFEAS_CER    SolSta = 6 // The solution is a certificate of dual infeasibility.
	SOL_STA_PRIM_ILLPOSED_CER  SolSta = 7 // The solution is a certificate that the primal problem is illposed.
	SOL_STA_DUAL_ILLPOSED_CER  SolSta = 8 // The solution is a certificate that the dual problem is illposed.
	SOL_STA_INTEGER_OPTIMAL    SolSta = 9 // The primal solution is integer optimal.
)

// SolType is MSKsoltype_enum
//
// Solution types
type SolType uint32

const (
	SOL_ITR SolType = 0 // The interior solution.
	SOL_BAS SolType = 1 // The basic solution.
	SOL_ITG SolType = 2 // The integer solution.
)

// Solveform is MSKsolveform_enum
//
// Solve primal or dual form
type Solveform uint32

const (
	SOLVE_FREE   Solveform = 0 // The optimizer is free to solve either the primal or the dual problem.
	SOLVE_PRIMAL Solveform = 1 // The optimizer should solve the primal problem.
	SOLVE_DUAL   Solveform = 2 // The optimizer should solve the dual problem.
)

// SParam is MSKsparam_enum
//
// string parameter.
type SParam uint32

const (
	SPAR_BAS_SOL_FILE_NAME         SParam = 0  // Name of the bas solution file.
	SPAR_DATA_FILE_NAME            SParam = 1  // Data are read and written to this file.
	SPAR_DEBUG_FILE_NAME           SParam = 2  // MOSEK debug file.
	SPAR_INT_SOL_FILE_NAME         SParam = 3  // Name of the int solution file.
	SPAR_ITR_SOL_FILE_NAME         SParam = 4  // Name of the itr solution file.
	SPAR_MIO_DEBUG_STRING          SParam = 5  // For internal debugging purposes.
	SPAR_PARAM_COMMENT_SIGN        SParam = 6  // Solution file comment character.
	SPAR_PARAM_READ_FILE_NAME      SParam = 7  // Modifications to the parameter database is read from this file.
	SPAR_PARAM_WRITE_FILE_NAME     SParam = 8  // The parameter database is written to this file.
	SPAR_READ_MPS_BOU_NAME         SParam = 9  // Name of the BOUNDS vector used. An empty name means that the first BOUNDS vector is used.
	SPAR_READ_MPS_OBJ_NAME         SParam = 10 // Objective name in the MPS file.
	SPAR_READ_MPS_RAN_NAME         SParam = 11 // Name of the RANGE vector  used. An empty name means that the first RANGE vector is used.
	SPAR_READ_MPS_RHS_NAME         SParam = 12 // Name of the RHS used. An empty name means that the first RHS vector is used.
	SPAR_REMOTE_OPTSERVER_HOST     SParam = 13 // URL of the remote optimization server.
	SPAR_REMOTE_TLS_CERT           SParam = 14 // Known server certificates in PEM format
	SPAR_REMOTE_TLS_CERT_PATH      SParam = 15 // Path to known server certificates in PEM format
	SPAR_SENSITIVITY_FILE_NAME     SParam = 16 // Sensitivity report file name.
	SPAR_SENSITIVITY_RES_FILE_NAME SParam = 17 // Name of the sensitivity report output file.
	SPAR_SOL_FILTER_XC_LOW         SParam = 18 // Solution file filter.
	SPAR_SOL_FILTER_XC_UPR         SParam = 19 // Solution file filter.
	SPAR_SOL_FILTER_XX_LOW         SParam = 20 // Solution file filter.
	SPAR_SOL_FILTER_XX_UPR         SParam = 21 // Solution file filter.
	SPAR_STAT_KEY                  SParam = 22 // Key used when writing the summary file.
	SPAR_STAT_NAME                 SParam = 23 // Name used when writing the statistics file.
	SPAR_WRITE_LP_GEN_VAR_NAME     SParam = 24 // Added variable names in the LP files.
)

// StaKey is MSKstakey_enum
//
// Status keys
type StaKey uint32

const (
	SK_UNK    StaKey = 0 // The status for the constraint or variable is unknown.
	SK_BAS    StaKey = 1 // The constraint or variable is in the basis.
	SK_SUPBAS StaKey = 2 // The constraint or variable is super basic.
	SK_LOW    StaKey = 3 // The constraint or variable is at its lower bound.
	SK_UPR    StaKey = 4 // The constraint or variable is at its upper bound.
	SK_FIX    StaKey = 5 // The constraint or variable is fixed.
	SK_INF    StaKey = 6 // The constraint or variable is infeasible in the bounds.
)

// StarPointType is MSKstartpointtype_enum
//
// Starting point types
type StarPointType uint32

const (
	STARTING_POINT_FREE           StarPointType = 0 // The starting point is chosen automatically.
	STARTING_POINT_GUESS          StarPointType = 1 // The optimizer guesses a starting point.
	STARTING_POINT_CONSTANT       StarPointType = 2 // The optimizer constructs a starting point by assigning a constant value to all primal and dual variables. This starting point is normally robust.
	STARTING_POINT_SATISFY_BOUNDS StarPointType = 3 // The starting point satisfies all the simple bounds on nonlinear variables.
)

// StreamType is MSKstreamtype_enum
//
// Stream types
type StreamType uint32

const (
	STREAM_LOG StreamType = 0 // Log stream. Contains the aggregated contents of all other streams. This means that a message written to any other stream will also be written to this stream.
	STREAM_MSG StreamType = 1 // Message stream. Log information relating to performance and progress of the optimization is written to this stream.
	STREAM_ERR StreamType = 2 // Error stream. Error messages are written to this stream.
	STREAM_WRN StreamType = 3 // Warning stream. Warning messages are written to this stream.
)

// VariableType is MSKvariabletype_enum
//
// Variable types
type VariableType uint32

const (
	VAR_TYPE_CONT VariableType = 0 // Is a continuous variable.
	VAR_TYPE_INT  VariableType = 1 // Is an integer variable.
)
